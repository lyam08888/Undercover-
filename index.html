<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
<title>Undercover 3.0 - Révolution</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
<meta name="theme-color" content="#0D1117">
<style>
  #tsparticles {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
  }
  :root{
    --bg: #0D1117;
    --surface: #161B22;
    --surface-light: #2c333d;
    --border: #30363d;
    --ink: #e6edf3;
    --muted: #8b949e;
    --accent: #38BDF8;
    --accent-glow: rgba(56, 189, 248, 0.3);
    --danger: #F472B6;
    --warn: #FBBF24;
    --success: #34D399;
    --r: 12px;
  }
  *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
  html,body{height:100%; overflow: hidden;}
  body{
    margin:0; font-family: 'Inter', sans-serif;
    color:var(--ink);
    background-color: var(--bg);
    background-image: radial-gradient(circle at 10% 10%, var(--accent-glow), transparent 40%), radial-gradient(circle at 90% 90%, rgba(244, 114, 182, 0.1), transparent 40%);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    display: grid;
    place-items: center;
  }
  .app{
    width: 100%;
    height: 100vh; /* Use viewport height to solve mobile screen issue */
    display:flex;
    flex-direction:column; 
    position: relative; 
    background: var(--bg);
    overflow: hidden;
  }
  header{position:sticky;top:0;z-index:10;background: rgba(13, 17, 23, 0.7);
    backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
    border-bottom:1px solid var(--border); display: none;}
  .bar{display:flex;align-items:center;gap:.75rem;padding:.75rem 1rem; height: 60px;}
  .title{font-weight:800; font-size:1.1rem;}
  .spacer{flex:1}
  .icon-btn{background: transparent; border:none; color:var(--muted); padding:.5rem; border-radius:50%; display:inline-flex;align-items:center; cursor:pointer; transition: all .2s ease;}
  .icon-btn:hover, .icon-btn:focus { color:var(--ink); background: var(--surface); }
  main{flex:1; display:flex;flex-direction:column; overflow: hidden; position: relative;}
  .screen{position:absolute; top:0; left:0; width:100%; height:100%; display:flex; flex-direction:column; padding:1rem; overflow-y:auto; opacity:0; visibility:hidden; animation-fill-mode: both; pointer-events: none; z-index: 1;}
  .screen.active{opacity:1; visibility:visible; pointer-events: auto; z-index: 2;}
  .screen.slide-out { animation: slideOut .3s ease-out forwards; }
  .screen.slide-in { animation: slideIn .3s ease-in forwards; }
  .card{background:var(--surface); border-radius:var(--r); padding:1.2rem; border: 1px solid var(--border); animation: fadeInUp .4s .1s both; display: flex; flex-direction: column; flex: 1;}
  h1{font-size:1.5rem;margin:0 0 1rem 0; font-weight: 800; color: var(--accent); display: flex; align-items: center; gap: 0.5rem;}
  h2{font-size:1.1rem;margin:1.5rem 0 .75rem 0;color:var(--muted); font-weight: 700;}
  .row{display:flex;gap:.75rem;align-items:center;flex-wrap:wrap}
  input[type="text"], select{width:100%; padding:.75rem 1rem; font-size:1rem; color:var(--ink); background:var(--bg); border:1px solid var(--border); border-radius:8px; outline:none; transition: all .2s ease;}
  input[type="text"]:focus, select:focus {border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-glow);}
  .pill{display:flex; align-items:center; justify-content:space-between; gap:.75rem; padding:.75rem 1rem; border-radius:8px; border:1px solid var(--border); background:var(--bg);}
  .numstep{display:flex;align-items:center;gap:.55rem}
  .step-btn{width:40px;height:40px;border-radius:8px;border:1px solid var(--border); background:var(--surface-light); color:var(--ink); font-size:1.25rem; font-weight:600; cursor:pointer; transition: all .2s ease;}
  .step-btn:hover { border-color: var(--accent); }
  .counter{min-width:40px;text-align:center;font-weight:700;font-size:1.25rem}
  .btn{width:100%; padding:1rem 1.1rem; border-radius:8px; font-weight:700; border:none; color:var(--bg); background:var(--accent); font-size:1rem; cursor:pointer; transition: all .2s ease; -webkit-tap-highlight-color: transparent;}
  .btn:hover { filter: brightness(1.1); }
  .btn:active { transform: scale(0.98); }
  .btn.ghost{background:var(--surface-light); color:var(--ink); border:1px solid var(--border);}
  .btn.ghost:hover{border-color:var(--muted);}
  .btn.danger{background:var(--danger); color: #fff;}
  .players{display:flex;flex-direction:column; gap:.6rem}
  .player-row{display:flex; align-items:center; gap:.7rem; padding:.5rem; border-radius:8px; background: var(--surface-light);}
  .avatar{width:48px;height:48px;border-radius:8px;display:grid;place-items:center;font-weight:700; background:var(--bg); color:var(--muted); overflow:hidden; position:relative; flex-shrink: 0;}
  .avatar img{width:100%;height:100%;object-fit:cover;display:block}
  .center{display:grid;place-items:center; flex: 1; text-align: center;}
  .hint{font-size:.9rem;color:var(--muted); line-height: 1.5; max-width: 40ch; margin: 0 auto;}
  dialog{ border:none; border-radius:var(--r); background: var(--surface); color:var(--ink); padding:0; box-shadow:0 25px 50px -12px rgba(0,0,0,0.5); width:min(92vw,420px); border: 1px solid var(--border);}
  dialog::backdrop{background:rgba(0,0,0,.6); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);}
  dialog[open]{animation: zoomIn .2s ease-out;}
  @keyframes zoomIn {from{opacity:0; transform:scale(.95)}}
  .modal{padding:1.5rem}
  .modal h2 {margin:0 0 .5rem 0; font-weight: 700; font-size: 1.25rem; color: var(--accent);}
  .modal p {margin:.5rem 0 1.5rem 0; color: var(--muted); line-height: 1.6;}
  .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0; }

  .tip-box {
    font-size: .85rem;
    color: var(--muted);
    background-color: var(--surface);
    padding: .75rem 1rem;
    border-radius: 8px;
    border: 1px solid var(--border);
    line-height: 1.5;
    text-align: center;
  }
  .tip-box::before {
    content: '💡 Astuce : ';
    font-weight: 700;
    color: var(--accent);
  }

  /* Action Bar */
  .action-bar{ position: fixed; bottom: 0; left: 0; right: 0; z-index: 10; padding: .75rem; background: linear-gradient(180deg, transparent, var(--bg) 80%); display: none; max-width: 480px; margin: 0 auto; animation: slideUp .3s ease-out; }
  .action-bar.visible { display: flex; gap: .75rem; }
  @keyframes slideUp { from { transform: translateY(100%); } to { transform: translateY(0); } }

  /* Pass Screen */
  .pass-container { display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 1.5rem; flex: 1; user-select: none;}
  .reveal-card-wrapper { perspective: 1500px; }
  .reveal-card {
    width: 85vw;
    max-width: 300px;
    aspect-ratio: 5 / 7;
    border-radius: var(--r);
    background: linear-gradient(165deg, var(--surface), #21262d);
    cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center;
    padding: 1.5rem; text-align: center;
    transition: transform 0.6s cubic-bezier(0.22, 1, 0.36, 1), box-shadow .3s ease, opacity .3s ease-in-out;
    border: 1px solid var(--border);
    box-shadow: 0 0 2px rgba(0,0,0,0.2), 0 4px 12px rgba(0,0,0,0.3);
    position: relative;
    transform-style: preserve-3d;
  }
  .reveal-card .icon { font-size: 3rem; margin-bottom: 1rem; color: var(--accent); transition: transform .3s ease; }
  .reveal-card .text { font-weight: 600; font-size: 1rem; }
  .reveal-card.flipped { transform: rotateY(180deg); }
  .card-face { position: absolute; top:0; left:0; width:100%; height:100%; -webkit-backface-visibility: hidden; backface-visibility: hidden; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 1.5rem; }
  .card-back { transform: rotateY(180deg); }
  .word-big { font-size: 2rem; font-weight: 800; color: var(--accent); }
  
  /* Game Screen */
  .game-container { width: 100%; height: 100%; display: flex; flex-direction: column; }
  .turn-display { display: flex; flex-direction: column; align-items: center; gap: 1rem; padding: 1rem; background: var(--surface); border-radius: var(--r); margin-bottom: 1rem; animation: slideDown .5s both; text-align: center;}
  .turn-player-avatar { width: 60px; height: 60px; border-radius: 50%; position: relative; margin: 0 auto .5rem auto; }
  .turn-player-avatar .avatar { width: 100%; height: 100%; border-radius: 50%; }
  .turn-timer-ring { position: absolute; top: -5px; left: -5px; width: 70px; height: 70px; }
  .turn-timer-circle { stroke: var(--accent); stroke-width: 4; fill: transparent; transition: stroke-dashoffset 0.2s linear, stroke 0.3s; transform: rotate(-90deg); transform-origin: 50% 50%; }
  .turn-player-name { font-size: 1.1rem; font-weight: 700; }
  .game-content-area { flex: 1; display: grid; place-items: center; text-align: center; padding: 1rem; }
  .hint-text { font-size: 2.5rem; font-weight: 800; animation: fadeIn .5s ease; }
  .vote-timer-display { text-align: center; font-size: 3rem; font-weight: 800; color: var(--accent); animation: pulse 1s infinite; }
  .player-grid-vote { display: grid; grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); gap: 1rem; padding: 1rem 0; width: 100%;}
  .player-vote-card { display: flex; flex-direction: column; align-items: center; gap: .5rem; padding: 1rem; background: var(--surface); border-radius: var(--r); border: 2px solid transparent; cursor: pointer; transition: all .2s ease; }
  .player-vote-card:not(.disabled):hover { transform: translateY(-4px); border-color: var(--muted); }
  .player-vote-card.voted { border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-glow); transform: scale(1.05); }
  .player-vote-card .avatar { width: 64px; height: 64px; border-radius: 50%; }
  .player-vote-card .name { font-weight: 600; font-size: 0.9rem; }
  .player-vote-card.disabled { opacity: 0.6; cursor: not-allowed; }

  /* Setup Steps */
  .setup-step {
    position: absolute;
    top: 1rem;
    left: 1rem;
    right: 1rem;
    bottom: 1rem;
    overflow-y: auto;
    opacity: 0;
    visibility: hidden;
    display: flex;
    flex-direction: column;
  }
  .setup-step.active { opacity: 1; visibility: visible; }

  /* Setup Options */
  .option-card {
    display: flex; flex-direction: column; align-items: center; justify-content: center; gap: .5rem;
    padding: 1rem .5rem; background: var(--bg); border: 1px solid var(--border);
    border-radius: 8px; cursor: pointer; transition: all .2s ease; text-align: center;
    flex: 1;
  }
  .option-card.active { background: var(--surface-light); border-color: var(--accent); }
  .option-card .icon { font-size: 1.5rem; }
  .option-card .label { font-size: .9rem; font-weight: 600; }
  .option-card .value { font-size: .8rem; color: var(--muted); }

  .theme-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: .75rem; margin-top: 1rem; }
  .theme-card {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    padding: 0.8rem;
    text-align: center;
    border: 1px solid var(--border);
    border-radius: 12px;
    cursor: pointer;
    transition: all .2s ease;
    background: var(--bg); /* To contrast with parent .card */
    aspect-ratio: 1 / 1;
  }
  .theme-card:hover {
    transform: translateY(-3px);
    border-color: var(--accent);
  }
  .theme-card.active {
    background: var(--surface-light);
    border-color: var(--accent);
    box-shadow: 0 0 0 3px var(--accent-glow);
    transform: translateY(-3px);
  }
  .theme-card .icon {
    font-size: 1.5rem;
    line-height: 1;
    background: var(--surface);
    padding: .75rem;
    border-radius: 8px;
    display: grid;
    place-items: center;
  }
  .theme-card .label {
    font-size: .9rem;
    font-weight: 700;
    margin-top: 0;
  }

  /* Home Screen */
  .home-title {
    font-size: clamp(2rem, 10vw, 3.2rem);
    font-weight: 800;
    text-align: center;
    letter-spacing: -1.5px;
    background: linear-gradient(90deg, var(--accent), #fff, var(--danger), var(--accent));
    background-size: 300% auto;
    background-clip: text;
    -webkit-background-clip: text;
    color: transparent;
    animation: title-shimmer 6s linear infinite;
  }
  .home-title .accent { color: inherit; } /* Inherit the gradient */

  @keyframes title-shimmer {
    to {
        background-position: -300% center;
    }
  }

  .confetti-particle {
    position: fixed;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    pointer-events: none;
    opacity: 0;
    animation: confetti-burst 0.9s ease-out forwards;
  }

  @keyframes confetti-burst {
    0% { transform: scale(1); opacity: 1; }
    100% { transform: translate(var(--x), var(--y)) scale(0); opacity: 0; }
  }

  .floating-word {
    position: absolute;
    font-size: 1.2rem;
    font-weight: 600;
    color: var(--muted);
    opacity: 0;
    animation: float-and-fade 5s ease-in-out forwards;
    pointer-events: none;
    white-space: nowrap;
    z-index: 0;
  }

  @keyframes float-and-fade {
    0% { transform: translateY(20px) scale(0.8); opacity: 0; }
    20%, 80% { transform: translateY(-20px) scale(1); opacity: 0.6; }
    100% { transform: translateY(-60px) scale(0.7); opacity: 0; }
  }

  /* Vote Reveal */
  .vote-reveal-grid { display: grid; grid-template-columns: 1fr auto 1fr; align-items: center; gap: 1rem; margin-top: 1rem; padding: 0.5rem 0; border-bottom: 1px solid var(--border); }
  .vote-reveal-grid:last-child { border-bottom: none; }
  .vote-reveal-item { display: flex; flex-direction: column; align-items: center; gap: 0.5rem; text-align: center; }
  .vote-reveal-item .avatar { width: 56px; height: 56px; border-radius: 50%; }
  .vote-reveal-item .name { font-size: 0.9rem; font-weight: 600; }
  .vote-arrow { font-size: 2rem; color: var(--muted); }
  .vote-arrow.suspect { color: var(--danger); font-weight: bold; }
  
  /* Event Screen */
  #screen-event .center { gap: 1.5rem; }
  #event-icon { font-size: 4rem; animation: zoomIn .5s both; }
  #event-title { font-size: 2rem; animation: fadeInUp .5s .2s both; }
  #event-description { max-width: 45ch; animation: fadeInUp .5s .4s both; }
  
  /* Animations */
  @keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
  @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
  @keyframes slideDown { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
  @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
  @keyframes slideOut { to { opacity: 0; transform: translateX(-50%); visibility: hidden; } }
  @keyframes slideIn { from { opacity: 0; transform: translateX(50%); } to { opacity: 1; transform: translateX(0); visibility: visible;} }
  .reveal-avatar { animation: zoomIn .5s .1s both; }
  .reveal-title { animation: fadeInUp .5s .3s both; }
  .reveal-card-info { animation: fadeInUp .5s .5s both; }
  .winner-banner { animation: zoomIn .5s cubic-bezier(0.25, 2.5, 0.5, 1) both; }

  @keyframes title-glow {
    from { text-shadow: 0 0 10px var(--accent-glow), 0 0 20px var(--accent-glow); }
    to { text-shadow: 0 0 20px var(--accent-glow), 0 0 30px var(--accent-glow), 0 0 5px var(--accent); }
  }

  @keyframes slide-out-left { from { transform: translateX(0); opacity: 1; } to { transform: translateX(-100%); opacity: 0; } }
  @keyframes slide-in-right { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
  @keyframes slide-out-right { from { transform: translateX(0); opacity: 1; } to { transform: translateX(100%); opacity: 0; } }
  @keyframes slide-in-left { from { transform: translateX(-100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
  .slide-out-left { animation: slide-out-left 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards; }
  .slide-in-right { animation: slide-in-right 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards; }
  .slide-out-right { animation: slide-out-right 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards; }
  .slide-in-left { animation: slide-in-left 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards; }

  @media (min-width: 501px) {
    .app {
      max-width: 480px;
      height: 95vh;
      max-height: 900px;
      border-radius: 16px;
      box-shadow: 0 0 80px rgba(0,0,0,0.5);
    }
  }
</style>
<script src="https://cdn.jsdelivr.net/npm/tsparticles@3.4.0/tsparticles.bundle.min.js"></script>
</head>
<body>
<div id="tsparticles"></div>
<div class="app">
  <header id="game-header">
    <div class="bar">
      <div class="title">Undercover 3.0</div>
      <div class="spacer"></div>
      <button id="btnShowMyCard" class="icon-btn" title="Voir ma carte" style="display: none;"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></svg></button>
      <button id="btnNewWord" class="icon-btn" title="Nouveau mot" style="display: none;"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/></svg></button>
      <button id="btnReset" class="icon-btn" title="Nouvelle partie"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 1 1-6.219-8.56"/></svg></button>
      <button id="btnHelp" class="icon-btn" title="Règles"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><path d="M12 17h.01"/></svg></button>
    </div>
  </header>

  <main>
    <!-- HOME -->
    <section id="screen-home" class="screen active">
    <div class="center" style="display: flex; flex-direction: column; justify-content: space-around; align-items: center; padding: 3rem 1rem;">
            <div class="title-container" style="position: relative; z-index: 1;">
              <h1 class="home-title" style="animation: fadeInUp .5s .1s both;">Undercover<span class="accent"> 3.0</span></h1>
            </div>
        <div style="animation: fadeInUp .5s .3s both; display: flex; flex-direction: column; gap: .75rem; width: 80%; max-width: 300px;">
                <button id="start-game-btn" class="btn" style="width: 100%; padding: 1rem 2rem;">Commencer à jouer</button>
            </div>
        <div class="tip-box" style="animation: fadeInUp .5s .5s both; max-width: 380px;">Le but est simple : les Civils doivent démasquer les Undercover, et les Undercover doivent survivre !</div>
        </div>
    </section>

    <!-- SETUP -->
    <section id="screen-setup" class="screen">
        <!-- Step 1: Mode -->
        <div class="setup-step active" data-step="1">
            <div class="card">
                <h1><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>Mode de Jeu</h1>
                <div class="row" style="margin-top: 1rem;">
                    <div id="mode-classic" class="option-card"><div class="icon">☕</div><div class="label">Classique</div><div class="value">Oral, avec timer</div></div>
                    <div id="mode-dynamic" class="option-card active"><div class="icon">⚡</div><div class="label">Dynamique</div><div class="value">Timer & Événements</div></div>
                    <div id="mode-revolution" class="option-card"><div class="icon">💥</div><div class="label">Révolution</div><div class="value">Événements intenses</div></div>
                    <div id="mode-fast" class="option-card"><div class="icon">⏱️</div><div class="label">Rapide</div><div class="value">Timers courts</div></div>
                </div>
            </div>
        </div>
        <!-- Step 2: Mission -->
        <div class="setup-step" data-step="2">
            <div class="card">
                <h1><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2.5 17a2.4 2.4 0 0 1 3 0L8 20l3-3a2.4 2.4 0 0 1 3 0L19.5 20a2.4 2.4 0 0 1 0-3L17 15l3-3a2.4 2.4 0 0 0 0-3L15 4l-3 3a2.4 2.4 0 0 0-3 0L4 4a2.4 2.4 0 0 0 0 3l3 3-2.5 2.5a2.4 2.4 0 0 0 0 3Z"/></svg>Choisissez un thème</h1>
                <div id="theme-grid" style="margin-top: 1rem; flex: 1;"></div>
            </div>
        </div>
        <!-- Step 3: Agents -->
        <div class="setup-step" data-step="3">
            <div class="card">
                <h1><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>Paramétrez les agents</h1>
                <div class="row" style="margin-top:1rem"><div class="pill" style="flex:1.5"><span><b>Agents Humains</b> (0–12)</span><div class="numstep"><button id="minus" class="step-btn">−</button><div id="playerNum" class="counter">4</div><button id="plus" class="step-btn">+</button></div></div><div class="pill" style="flex:1"><span>Bots IA</span><div class="numstep"><button id="minusBot" class="step-btn">−</button><div id="botNum" class="counter">0</div><button id="plusBot" class="step-btn">+</button></div></div></div>
                <p class="hint" style="margin-top: auto; text-align: center; padding-top: 1rem;">Le nombre total d'agents (humains + bots) doit être entre 3 et 12.</p>
            </div>
        </div>
        <!-- Step 4: Options -->
        <div class="setup-step" data-step="4">
            <div class="card">
                <h1 style="font-size: 1.25rem;"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 0 2l-.15.08a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l-.22-.38a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1 0-2l.15-.08a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>Options de la partie</h1>
                <div class="setup-options" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); gap: .75rem; align-content: center; flex: 1;">
                    <div id="option-sound" class="option-card"><div class="icon">🔊</div><div class="label">Sons</div><div class="value">Désactivé</div></div>
                    <div id="option-innocent" class="option-card"><div class="icon">😇</div><div class="label">Innocent</div><div class="value">Désactivé</div></div>
                    <div id="option-jester" class="option-card"><div class="icon">🃏</div><div class="label">Jester</div><div class="value">Désactivé</div></div>
                    <div id="option-agent-blanc" class="option-card"><div class="icon">🕵️</div><div class="label">Agent Blanc</div><div class="value">Désactivé</div></div>
                </div>
            </div>
        </div>
        <!-- Step 5: Players -->
        <div class="setup-step" data-step="5">
            <div class="card">
                <h1 style="font-size: 1.25rem;"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>Agents Humains</h1>
                <div id="playersSetup" class="players" style="flex: 1; overflow-y: auto;"></div>
            </div>
        </div>
    </section>

    <!-- PASS & CARD REVEAL -->
    <section id="screen-pass" class="screen">
        <div class="pass-container">
            <div style="text-align:center;"><h1>Passez à <b id="currentName"></b></h1><p class="hint">Touchez la carte pour révéler votre rôle secret. <br>Cachez-la avant de passer au suivant.</p></div>
            <div class="reveal-card-wrapper"><div id="revealCard" class="reveal-card"><div class="card-face card-front"><div class="icon">?</div><div class="text">TOUCHER POUR RÉVÉLER</div></div><div class="card-face card-back"><div id="secretWord" class="word-big"></div></div></div></div>
        </div>
    </section>

    <!-- GAME ROUND -->
    <section id="screen-game" class="screen">
        <div class="game-container">
            <div id="turn-display" class="turn-display"></div>
            <div id="game-content-area" class="game-content-area"></div>
            <div class="tip-box" style="margin: 0 1rem 1rem 1rem;">Observez les réactions des autres après chaque indice. Une hésitation peut être révélatrice.</div>
        </div>
    </section>
    
    <!-- EVENT -->
    <section id="screen-event" class="screen">
        <div class="center">
            <div id="event-icon"></div>
            <h1 id="event-title"></h1>
            <p id="event-description" class="hint"></p>
            <div class="tip-box" style="margin-top: 2rem;">Les événements peuvent retourner la situation. Utilisez-les à votre avantage !</div>
        </div>
    </section>

    <!-- REVEAL / RESULT -->
    <section id="screen-reveal" class="screen">
      <div class="center" style="gap:.8rem;"><div id="revealPhoto" class="avatar reveal-avatar" style="width:120px;height:120px;border-radius:50%;"></div><h1 id="revealTitle" class="reveal-title" style="margin-top: 1rem;"></h1><div class="card reveal-card-info" style="max-width:400px; width: 100%;"><div id="roleBadge" style="font-weight: 600; color: var(--muted); margin-bottom: .5rem;">Rôle</div><div id="revealedWord" style="font-size: 1.2rem; font-weight: 700;"></div></div>
      <div class="tip-box" style="margin-top: 1.5rem;">Si un Civil est éliminé, les Undercover gagnent du terrain. S'il s'agissait d'un Undercover, vous êtes plus proches de la victoire !</div></div>
    </section>
    
    <!-- LAST WORD -->
    <section id="screen-lastword" class="screen">
        <div class="center" style="gap: 1rem;">
            <h1>Dernier Mot</h1>
            <p class="hint" id="lastword-prompt"></p>
            <div id="lastword-grid" class="player-grid-vote"></div>
            <div class="tip-box">Votre "dernier mot" peut influencer le prochain vote. Choisissez judicieusement !</div>
        </div>
    </section>

    <!-- END -->
    <section id="screen-end" class="screen">
      <div class="center" style="gap:.8rem;"><h1 id="winnerBanner" class="winner-banner" style="font-size: 2.5rem;"></h1><p id="summary" class="hint" style="max-width: 400px; animation: fadeInUp .5s .2s both;"></p>
      <div id="vote-reveal-container" class="card" style="width: 100%; max-width: 400px; display:none; animation: fadeInUp .5s .4s both;">
        <h2>Qui a voté contre qui ?</h2>
        <div id="vote-reveal-details"></div>
      </div>
      <div class="tip-box" style="animation: fadeInUp .5s .6s both;">Chaque partie est différente. Essayez de nouvelles stratégies, de nouveaux thèmes et de nouveaux rôles !</div>
      </div>
    </section>
  </main>

  <div id="actionBar" class="action-bar"></div>
</div>

<!-- Modals -->
<dialog id="modal-template">
    <div class="modal"><h2 id="modal-title"></h2><p id="modal-message"></p><div id="modal-input-wrap" style="display:none;"><input type="text" id="modal-input" style="width: 100%;"></div><div id="modal-actions" class="row" style="margin-top:1.5rem"></div></div>
</dialog>

<script>
(function(){
  // ---------- WORD DATA V4 ----------
  const THEME_DATA = {
    "Culture Pop": [
      {a:"Pokémon",b:"Digimon", hintsA:["capture", "pokéball", "arène"], hintsB:["digital", "monde", "données"]},
      {a:"Marvel",b:"DC Comics", hintsA:["iron man", "avengers", "cinéma"], hintsB:["batman", "justice league", "sombre"]},
      {a:"Harry Potter",b:"Seigneur des Anneaux", hintsA:["baguette", "sorcier", "école"], hintsB:["anneau", "communauté", "quête"]},
      {a:"Twitch",b:"YouTube", hintsA:["stream", "emote", "abonnement"], hintsB:["vidéo", "chaîne", "playlist"]},
      {a:"Star Wars", b:"Star Trek", hintsA:["force", "sabre laser", "jedi"], hintsB:["fédération", "vaisseau", "exploration"]},
      {a:"Mario",b:"Sonic", hintsA:["plombier", "champignon", "princesse"], hintsB:["hérisson", "vitesse", "anneaux"]},
      {a:"Fortnite",b:"Minecraft", hintsA:["battle royale", "construction", "skin"], hintsB:["blocs", "crafting", "survie"]},
      {a:"Netflix",b:"Disney+", hintsA:["streaming", "série", "binge"], hintsB:["streaming", "famille", "mickey"]},
    ],
    "Vie Quotidienne": [
      {a:"Pull",b:"Gilet", hintsA:["laine", "manches", "col"], hintsB:["boutons", "sans manches", "cardigan"]},
      {a:"Café",b:"Thé", hintsA:["machine", "expresso", "arabica"], hintsB:["infusion", "sachet", "bouilloire"]},
      {a:"Fourchette",b:"Cuillère", hintsA:["piquer", "dents", "couvert"], hintsB:["contenir", "soupe", "ronde"]},
      {a:"Chaussette",b:"Collant", hintsA:["pied", "paire", "coton"], hintsB:["jambe", "nylon", "robe"]},
      {a:"Livre",b:"Magazine", hintsA:["chapitres", "roman", "auteur"], hintsB:["articles", "photos", "hebdomadaire"]},
      {a:"Bus", b:"Métro", hintsA:["arrêt", "surface", "ville"], hintsB:["station", "souterrain", "rail"]},
      {a:"T-shirt",b:"Chemise", hintsA:["coton", "manches courtes", "décontracté"], hintsB:["col", "boutons", "formel"]},
    ],
    "Gastronomie": [
      {a:"Baguette",b:"Croissant", hintsA:["longue", "salée", "pain"], hintsB:["viennoiserie", "beurre", "sucré"]},
      {a:"Camembert",b:"Roquefort", hintsA:["vache", "normandie", "croute"], hintsB:["brebis", "bleu", "cave"]},
      {a:"Raclette",b:"Fondue", hintsA:["pomme de terre", "fromage fondu", "charcuterie"], hintsB:["pain", "fromage fondu", "caquelon"]},
      {a:"Sel",b:"Poivre", hintsA:["blanc", "cristal", "mer"], hintsB:["noir", "grain", "épice"]},
      {a:"Vin rouge",b:"Vin blanc", hintsA:["viande", "tannin", "sombre"], hintsB:["poisson", "sec", "clair"]},
    ],
    "Culture G & Arts": [
        {a:"Tour Eiffel",b:"Arc de Triomphe", hintsA:["fer", "champs de mars", "antenne"], hintsB:["pierre", "étoile", "tombe"]},
        {a:"Molière",b:"Victor Hugo", hintsA:["théâtre", "comédie", "farce"], hintsB:["roman", "poésie", "misérables"]},
        {a:"Peinture",b:"Sculpture", hintsA:["toile", "pinceau", "couleur"], hintsB:["volume", "marbre", "statue"]},
        {a:"Joconde",b:"Cri", hintsA:["sourire", "da vinci", "louvre"], hintsB:["angoisse", "munch", "pont"]},
        {a:"Mozart",b:"Beethoven", hintsA:["prodige", "opéra", "autriche"], hintsB:["sourd", "symphonie", "allemagne"]},
    ],
    "Lieux & Voyages": [
        {a:"Paris",b:"Londres", hintsA:["seine", "capitale", "france"], hintsB:["tamise", "capitale", "angleterre"]},
        {a:"Alpes",b:"Pyrénées", hintsA:["mont blanc", "ski", "haute"], hintsB:["frontière", "espagne", "chaîne"]},
        {a:"Japon",b:"Chine", hintsA:["sushi", "tokyo", "île"], hintsB:["muraille", "pékin", "continent"]},
        {a:"Plage",b:"Montagne", hintsA:["sable", "mer", "vague"], hintsB:["neige", "sommet", "rocher"]},
        {a:"Désert",b:"Forêt", hintsA:["chaud", "sable", "cactus"], hintsB:["humide", "arbres", "verdure"]},
    ],
    "Animaux & Nature": [
      {a:"Chat",b:"Chien", hintsA:["félin", "indépendant", "griffes"], hintsB:["canin", "fidèle", "aboie"]},
      {a:"Lion",b:"Tigre", hintsA:["savane", "roi", "crinière"], hintsB:["jungle", "rayures", "solitaire"]},
      {a:"Abeille",b:"Guêpe", hintsA:["miel", "ruche", "pollen"], hintsB:["dard", "agressive", "jaune"]},
      {a:"Rose",b:"Tulipe", hintsA:["épines", "rouge", "fleur"], hintsB:["bulbe", "hollande", "pétale"]},
      {a:"Soleil",b:"Lune", hintsA:["jour", "étoile", "chaleur"], hintsB:["nuit", "satellite", "lumière"]},
    ],
    "Science & Tech": [
      {a:"Apple",b:"Microsoft", hintsA:["iphone", "mac", "design"], hintsB:["windows", "office", "logiciel"]},
      {a:"ADN",b:"ARN", hintsA:["double hélice", "génétique", "chromosome"], hintsB:["simple brin", "messager", "transcription"]},
      {a:"Voiture électrique",b:"Voiture thermique", hintsA:["batterie", "recharge", "silence"], hintsB:["essence", "moteur", "pollution"]},
      {a:"Astronaute",b:"Cosmonaute", hintsA:["nasa", "américain", "espace"], hintsB:["roscosmos", "russe", "espace"]},
    ],
    "Sport": [
      {a:"Football",b:"Rugby", hintsA:["rond", "pied", "but"], hintsB:["ovale", "main", "essai"]},
      {a:"Tennis",b:"Badminton", hintsA:["raquette", "balle", "filet"], hintsB:["raquette", "volant", "léger"]},
      {a:"Formule 1",b:"Rallye", hintsA:["circuit", "rapide", "monoplace"], hintsB:["spéciale", "dérapage", "copilote"]},
      {a:"Judo",b:"Karaté", hintsA:["prise", "tatami", "souplesse"], hintsB:["frappe", "dojo", "kata"]},
      {a:"Piscine",b:"Patinoire", hintsA:["eau", "nager", "maillot"], hintsB:["glace", "patiner", "froid"]},
    ],
    "Culture Algérienne": [
      {a:"Chorba",b:"Hrira", hintsA:["vermicelles", "soupe", "ramadan"], hintsB:["légumineuses", "soupe", "maroc"]},
      {a:"Couscous",b:"Berkoukes", hintsA:["fin", "semoule", "légumes"], hintsB:["gros", "plombs", "pâtes"]},
      {a:"Zlabia",b:"Makrout", hintsA:["friture", "miel", "sucré"], hintsB:["semoule", "datte", "gâteau"]},
      {a:"Thé à la menthe",b:"Café maure", hintsA:["vert", "infusion", "maghreb"], hintsB:["noir", "turc", "serré"]},
    ],
    "Mots Piégés & Absurdes": [
      {a:"Ornithorynque",b:"Pangolin", hintsA:["bec", "australie", "venin"], hintsB:["écailles", "fourmis", "roule"]},
      {a:"Schizophrène",b:"Paranoïaque", hintsA:["voix", "hallucination", "dissociation"], hintsB:["méfiance", "complot", "persécution"]},
      {a:"Clé",b:"Serrure", hintsA:["tourne", "porte", "métal"], hintsB:["reçoit", "trou", "verrou"]},
      {a:"Haut",b:"Bas", hintsA:["ciel", "dessus", "monter"], hintsB:["sol", "dessous", "descendre"]},
      {a:"Gauche",b:"Droite", hintsA:["politique", "main", "coeur"], hintsB:["politique", "main", "sens"]},
    ],
    "Histoire & Mythologie": [
      {a:"Jules César",b:"Alexandre le Grand", hintsA:["rome", "gaule", "empereur"], hintsB:["macédoine", "perse", "conquérant"]},
      {a:"Cléopâtre",b:"Néfertiti", hintsA:["reine", "égypte", "nil"], hintsB:["reine", "égypte", "beauté"]},
      {a:"Zeus",b:"Poséidon", hintsA:["ciel", "foudre", "olympe"], hintsB:["mer", "trident", "océan"]},
      {a:"Lancelot",b:"Arthur", hintsA:["chevalier", "table ronde", "guenièvre"], hintsB:["roi", "excalibur", "camelot"]},
    ],
    "Marques Célèbres": [
      {a:"Coca-Cola",b:"Pepsi", hintsA:["rouge", "boisson", "américain"], hintsB:["bleu", "boisson", "concurrent"]},
      {a:"Nike",b:"Adidas", hintsA:["swoosh", "chaussure", "sport"], hintsB:["trois bandes", "chaussure", "allemand"]},
      {a:"Google",b:"Facebook", hintsA:["recherche", "moteur", "android"], hintsB:["social", "profil", "meta"]},
      {a:"McDonald's",b:"Burger King", hintsA:["arches", "big mac", "clown"], hintsB:["flamme", "whopper", "roi"]},
    ],
    "Corps Humain": [
      {a:"Cerveau",b:"Coeur", hintsA:["pensée", "organe", "tête"], hintsB:["sang", "organe", "pompe"]},
      {a:"Main",b:"Pied", hintsA:["doigts", "saisir", "bras"], hintsB:["orteils", "marcher", "jambe"]},
      {a:"Oeil",b:"Oreille", hintsA:["vision", "regarder", "couleur"], hintsB:["audition", "écouter", "son"]},
      {a:"Poumon",b:"Estomac", hintsA:["respiration", "air", "cage thoracique"], hintsB:["digestion", "nourriture", "acide"]},
    ]
  };
  const RANDOM_AGENT_NAMES = ["Spectre", "Vipère", "Corbeau", "Ombre", "Fantôme", "Loup", "Cobra", "Phénix", "Tigre", "Faucon", "Mirage", "Zodiac"];
  const TIPS = [
    "En tant que Civil, donnez un indice précis mais pas trop évident pour ne pas aider l'Undercover.",
    "En tant qu'Undercover, essayez de vous fondre dans la masse. Votre premier indice est crucial !",
    "Si un rôle 'Innocent' est en jeu, il gagne s'il est éliminé ET devine le mot des Civils. Ne le sous-estimez pas !",
    "Observez les réactions des autres après chaque indice. Une hésitation peut être révélatrice.",
    "N'hésitez pas à utiliser les événements à votre avantage, ils peuvent renverser la partie !",
    "Un vote blanc ou une égalité peut sauver un Undercover en difficulté. Discutez bien avant de voter !",
    "Si vous êtes l'Undercover et que vous avez une idée du mot des Civils, essayez de donner un indice qui correspond aux deux mots.",
    "En mode Révolution, préparez-vous à tout ! Les rôles peuvent changer à tout moment.",
    "N'ayez pas peur de voter contre quelqu'un qui semble sûr de lui, c'est peut-être une tactique !"
  ];
  const THEME_ICONS = { "Culture Pop": "🍿", "Vie Quotidienne": "🏠", "Gastronomie": "🍔", "Culture G & Arts": "🎨", "Lieux & Voyages": "✈️", "Animaux & Nature": "🐾", "Science & Tech": "🔬", "Sport": "⚽", "Culture Algérienne": "🇩🇿", "Mots Piégés & Absurdes": "🤪", "Histoire & Mythologie": "📜", "Marques Célèbres": "®️", "Corps Humain": "🧬", "random": "🎲" };

  // ---------- DOM & STATE ----------
  const dom = {};
  let setupAgentNames = [];
  const state = {
    players: [], wordPair: null,
    settings: { 
        gameMode: 'dynamic', // classic, dynamic, revolution
        theme: 'Culture Pop', 
        playerCount: 4, botCount: 0, 
        undercoverCount: 1, 
        sound:false, innocent:false, jester: false, agentBlanc: false
    },
    round: 1, distributionIndex: 0,
    lastEliminated: null, lastVotes: {}, lastSuspect: null,
    tabooWord: null,
    maxPlayers: 12, minPlayers: 3,
    setupStep: 1, isNavigating: false,
    _activeScreen: 'home', _gameController: null, _currentEvent: null
  };

  const getDOMElements = () => {
    const ids = [
      'screen-home', 'screen-setup', 'screen-pass', 'screen-game', 'screen-reveal', 'screen-end', 'screen-lastword', 'screen-event',
      'theme-grid', 'minus', 'plus', 'playerNum', 'minusBot', 'plusBot', 'botNum', 'playersSetup',
      'btnReset', 'btnHelp', 'btnNewWord', 'btnShowMyCard', 'option-sound', 'option-innocent', 'option-jester', 'option-agent-blanc',
      'mode-classic', 'mode-dynamic', 'mode-revolution', 'mode-fast',
      'currentName', 'revealCard', 'secretWord', 'start-game-btn', 'tips-btn', 'game-header',
      'turn-display', 'game-content-area', 'lastword-prompt', 'lastword-grid',
      'event-icon', 'event-title', 'event-description',
      'revealPhoto', 'revealTitle', 'roleBadge', 'revealedWord', 'winnerBanner', 'summary', 'actionBar',
      'vote-reveal-container', 'vote-reveal-details',
      'modal-template', 'modal-title', 'modal-message', 'modal-input-wrap', 'modal-input', 'modal-actions'
    ];
    ids.forEach(id => dom[id.replace(/-(\w)/g, (m, g) => g.toUpperCase())] = document.getElementById(id));
    dom.screens = {
        home: dom.screenHome, setup: dom.screenSetup, pass: dom.screenPass, game: dom.screenGame,
        reveal: dom.screenReveal, end: dom.screenEnd, lastword: dom.screenLastword, event: dom.screenEvent
    };
  };

  // ---------- UTILS ----------
  const rand = (n)=> Math.floor(Math.random()*n);
  const shuffle = (arr)=> arr.map(v=>[Math.random(),v]).sort((a,b)=>a[0]-b[0]).map(x=>x[1]);
  const byId = (id)=> state.players.find(p=>p.id===id);
  const alive = ()=> state.players.filter(p=>p.alive);
  const clamp = (n,min,max)=> Math.max(min, Math.min(max, n));
  
  function show(screenId, direction = 'forward'){
    const currentScreen = dom.screens[state._activeScreen];
    const nextScreen = dom.screens[screenId];

    if (!nextScreen || (currentScreen && currentScreen === nextScreen) || state.isNavigating) return;
    state.isNavigating = true;

    const outClass = direction === 'forward' ? 'slide-out-left' : 'slide-out-right';
    const inClass = direction === 'forward' ? 'slide-in-right' : 'slide-in-left';

    const animationPromises = [];

    if (currentScreen) {
        currentScreen.classList.add(outClass);
        animationPromises.push(new Promise(resolve => {
            currentScreen.addEventListener('animationend', function handler(e) {
                if (e.target === currentScreen) {
                    currentScreen.classList.remove('active', outClass);
                    currentScreen.removeEventListener('animationend', handler);
                    resolve();
                }
            }, { once: true });
        }));
    }

    nextScreen.classList.add('active');
    nextScreen.classList.add(inClass);
    animationPromises.push(new Promise(resolve => {
        nextScreen.addEventListener('animationend', function handler(e) {
            if (e.target === nextScreen) {
                nextScreen.classList.remove(inClass);
                nextScreen.removeEventListener('animationend', handler);
                resolve();
            }
        }, { once: true });
    }));

    Promise.all(animationPromises).then(() => {
        state.isNavigating = false;
    });

    state._activeScreen = screenId;
    dom.gameHeader.style.display = ['home', 'setup'].includes(screenId) ? 'none' : 'block';
    updateActionBar(screenId);
    const inGame = ['pass', 'game', 'reveal', 'lastword', 'event'].includes(screenId);
    dom.btnNewWord.style.display = inGame ? 'inline-flex' : 'none';
    dom.btnShowMyCard.style.display = inGame ? 'inline-flex' : 'none';
  }
  window.show = show; // Expose for testing

  // ---------- MODAL SYSTEM ----------
  const showModal = (config) => {
    dom.modalTitle.textContent = config.title;
    dom.modalMessage.innerHTML = config.message;
    dom.modalInputWrap.style.display = config.input ? 'block' : 'none';
    if (config.input) {
        dom.modalInput.placeholder = config.input.placeholder || '';
        dom.modalInput.value = '';
        setTimeout(() => dom.modalInput.focus(), 100);
    }
    dom.modalActions.innerHTML = '';
    if (config.buttons && config.buttons.length > 0) {
        config.buttons.forEach((btnConfig, i) => {
            const button = document.createElement('button');
            button.className = `btn ${btnConfig.class || ''}`;
            button.textContent = btnConfig.text;
            button.style.flex = 1;
            button.style.animation = `fadeInUp .4s ${150 + i * 60}ms both`;
            button.onclick = () => {
                const inputValue = config.input ? dom.modalInput.value : null;
                if (btnConfig.onClick) btnConfig.onClick(inputValue);
                if (!config.preventClose) dom.modalTemplate.close();
            };
            dom.modalActions.appendChild(button);
        });
    }
    if (dom.modalTemplate.open) dom.modalTemplate.close();
    dom.modalTemplate.showModal();
  };

  // ---------- AUDIO & HAPTICS ----------
  let audioCtx = null;
  function initAudio(){ if(!audioCtx){ const Ctx = window.AudioContext || window.webkitAudioContext; if(Ctx){ audioCtx = new Ctx(); } } if(audioCtx && audioCtx.state==='suspended'){ audioCtx.resume(); } }
  function beep(type='sine', freq=880, dur=0.1, vol=0.1){
    if(!state.settings.sound || !audioCtx) return;
    const t0 = audioCtx.currentTime;
    const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
    o.type=type; o.frequency.setValueAtTime(freq, t0);
    g.gain.setValueAtTime(0.0001, t0); g.gain.exponentialRampToValueAtTime(vol, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(t0); o.stop(t0 + dur);
  }
  function haptic(type = 'light') {
    if (navigator.vibrate) {
        navigator.vibrate(type === 'heavy' ? [50] : [20]);
    }
  }
  const sounds = {
    click: ()=> { beep('sine', 1200, 0.06); },
    flip: ()=> { beep('sine', 900, 0.08); haptic('light'); },
    start: ()=> { beep('sine', 740, 0.1); haptic('heavy'); },
    eliminate: ()=> { beep('sawtooth', 420, 0.15, 0.08); haptic('heavy'); },
    win: ()=> { beep('sine', 740, 0.1); setTimeout(()=>beep('sine', 880, 0.1),120); setTimeout(()=>beep('sine', 1046, 0.1),250); },
    lose: ()=> { beep('sine', 440, 0.1); setTimeout(()=>beep('sine', 330, 0.1),120); },
    tick: (fast=false)=> { if (!fast) beep('sine', 1000, 0.05, 0.05); },
    event: ()=> { beep('sawtooth', 1500, 0.05); setTimeout(()=>beep('sawtooth', 1800, 0.1), 80); }
  };

  // ---------- IMAGE & AVATAR ----------
  function fileToDataURL(file, maxW=520, maxH=520){
    return new Promise((resolve,reject)=>{
      const fr = new FileReader();
      fr.onload=()=>{ const img=new Image(); img.onload=()=>{ const r=Math.min(maxW/img.width,maxH/img.height,1),w=Math.round(img.width*r),h=Math.round(img.height*r); const c=document.createElement('canvas');c.width=w;c.height=h; c.getContext('2d').drawImage(img,0,0,w,h); resolve(c.toDataURL('image/jpeg',.9)); }; img.onerror=reject; img.src=fr.result; }; fr.onerror=reject; fr.readAsDataURL(file);
    });
  }
  function avatarHTML(p){
    if(p?.photo) return `<div class="avatar"><img src="${p.photo}" alt="photo ${p.name||'joueur'}"></div>`;
    const init = (p?.name||'Joueur').split(' ').map(x=>x[0]).slice(0,2).join('').toUpperCase();
    return `<div class="avatar">${init||'J'}</div>`;
  }

  // ---------- SETUP ----------
  function showSetupStep(step, direction = 'forward') {
    const fromStep = state.setupStep;
    const toStep = clamp(step, 1, 5);
    if (fromStep === toStep || state.isNavigating) return;

    state.isNavigating = true;

    const currentStepEl = document.querySelector(`.setup-step[data-step="${fromStep}"]`);
    const nextStepEl = document.querySelector(`.setup-step[data-step="${toStep}"]`);

    if (!nextStepEl) {
        state.isNavigating = false;
        return;
    }

    const outClass = direction === 'forward' ? 'slide-out-left' : 'slide-out-right';
    const inClass = direction === 'forward' ? 'slide-in-right' : 'slide-in-left';

    const animationPromises = [];

    if (currentStepEl) {
        currentStepEl.classList.add(outClass);
        animationPromises.push(new Promise(resolve => {
            currentStepEl.addEventListener('animationend', function handler(e) {
                if (e.target === currentStepEl) {
                    currentStepEl.classList.remove('active', outClass);
                    currentStepEl.removeEventListener('animationend', handler);
                    resolve();
                }
            }, { once: true });
        }));
    }

    nextStepEl.classList.add('active', inClass);
    animationPromises.push(new Promise(resolve => {
        nextStepEl.addEventListener('animationend', function handler(e) {
            if (e.target === nextStepEl) {
                nextStepEl.classList.remove(inClass);
                nextStepEl.removeEventListener('animationend', handler);
                resolve();
            }
        }, { once: true });
    }));

    Promise.all(animationPromises).then(() => {
        state.isNavigating = false;
    });
    state.setupStep = toStep;
    updateActionBar('setup');
  }

  function renderPlayerSetup(){
    dom.playersSetup.innerHTML='';
    const n = state.settings.playerCount;
    for (let i=0;i<n;i++){
      const p = state.players[i] || {id:i+1, name:'', photo:null};
      const row = document.createElement('div');
      row.className='player-row';
      row.style.animation = `fadeInUp .5s ${i * 50}ms both`;
      row.innerHTML = `
        ${avatarHTML(p)}
        <input type="text" placeholder="Nom de l'agent..." value="${p.name||''}" data-idx="${i}" style="flex:1">
        <div class="camera-row" style="display:flex; gap: 0.25rem;">
          <button class="icon-btn" data-random="${i}" title="Nom aléatoire"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 3h5v5"/><path d="M4 20L21 3"/><path d="M21 16v5h-5"/><path d="M15 15l6 6"/><path d="M4 4l5 5"/></svg></button>
          <button class="icon-btn" data-idx="${i}" title="Prendre/importer une photo"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/></svg></button>
          <button class="icon-btn" data-remove="${i}" title="Supprimer la photo" style="${p.photo ? '' : 'display:none;'}"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg></button>
          <input type="file" accept="image/*" data-file="${i}" class="sr-only">
        </div>`;
      dom.playersSetup.appendChild(row);
    }
    dom.playersSetup.querySelectorAll('input[type="text"]').forEach(inp=>inp.oninput=(e)=>{ const i=parseInt(e.target.dataset.idx,10); state.players[i]=state.players[i]||{id:i+1}; state.players[i].name=e.target.value; });
    dom.playersSetup.querySelectorAll('button[data-random]').forEach(btn=>btn.onclick=()=>{ const i=parseInt(btn.dataset.random,10); if(setupAgentNames.length === 0) setupAgentNames = shuffle([...RANDOM_AGENT_NAMES]); const newName = setupAgentNames.pop(); if(state.players[i]) { state.players[i].name = newName; } else { state.players[i] = {id:i+1, name: newName, photo: null}; } renderPlayerSetup(); });
    dom.playersSetup.querySelectorAll('button[data-idx]').forEach(btn=>btn.onclick=()=>{ const i=parseInt(btn.dataset.idx,10); dom.playersSetup.querySelector(`input[data-file="${i}"]`)?.click(); });
    dom.playersSetup.querySelectorAll('button[data-remove]').forEach(btn=>btn.onclick=()=>{ const i=parseInt(btn.dataset.remove,10); if(state.players[i])state.players[i].photo=null; renderPlayerSetup(); });
    dom.playersSetup.querySelectorAll('input[data-file]').forEach(inp=>inp.onchange=async(e)=>{ const i=parseInt(e.target.dataset.file,10); const file=e.target.files?.[0]; if(!file)return; try{const d=await fileToDataURL(file);(state.players[i]||={id:i+1}).photo=d;renderPlayerSetup();}catch{showModal({title:"Erreur",message:"Impossible de charger la photo.",buttons:[{text:"OK"}]})}});
  }

  function renderThemeSelection() {
      dom.themeGrid.innerHTML = '';
      const themes = [['Aléatoire', 'random'], ...Object.keys(THEME_DATA).map(t => [t,t])];

      themes.forEach(([name, value], i) => {
          const card = document.createElement('div');
          card.className = 'theme-card';
          card.dataset.theme = value;
          if (state.settings.theme === value) card.classList.add('active');
          card.innerHTML = `<div class="icon">${THEME_ICONS[value] || '✨'}</div><div class="label">${name}</div>`;
          card.style.animation = `fadeInUp .4s ${i * 30}ms both`;
          card.onclick = () => {
              state.settings.theme = value;
              sounds.click();
              dom.themeGrid.querySelectorAll('.theme-card').forEach(c => c.classList.remove('active'));
              card.classList.add('active');
          };
          dom.themeGrid.appendChild(card);
      });
  }

  function initSetup(){
    state.setupStep = 1;
    document.querySelectorAll('.setup-step').forEach(el => {
        el.classList.toggle('active', el.dataset.step === '1');
    });

    setupAgentNames = shuffle([...RANDOM_AGENT_NAMES]);
    
    renderThemeSelection();

    // Load saved players
    const savedPlayers = JSON.parse(localStorage.getItem('undercoverPlayers') || '[]');
    state.settings.playerCount = savedPlayers.length > 0 ? savedPlayers.length : 4;
    state.players = savedPlayers.length > 0 ? savedPlayers : Array.from({length:4}, (_,i)=>({id:i+1, name:'', photo:null}));

    dom.playerNum.textContent = state.settings.playerCount;
    dom.botNum.textContent = state.settings.botCount;
    renderPlayerSetup();
    
    const updateOptionCards = () => {
        ['sound', 'innocent', 'jester', 'agentBlanc'].forEach(key => {
            // Correctly constructs dom property name like 'optionInnocent' or 'optionAgentBlanc'
            const domKey = `option${key.charAt(0).toUpperCase() + key.slice(1)}`;
            const el = dom[domKey];
            if (!el) return;
            el.classList.toggle('active', state.settings[key]);
            el.querySelector('.value').textContent = state.settings[key] ? 'Activé' : 'Désactivé';
        });
        ['classic', 'dynamic', 'revolution', 'fast'].forEach(mode => {
            if(dom[`mode${mode.charAt(0).toUpperCase() + mode.slice(1)}`]) dom[`mode${mode.charAt(0).toUpperCase() + mode.slice(1)}`].classList.toggle('active', state.settings.gameMode === mode);
        });
    };
    updateOptionCards();

    const updateTotalPlayerCount = () => {
        const total = state.settings.playerCount + state.settings.botCount;
        if (total > state.maxPlayers) {
            state.settings.playerCount = state.maxPlayers - state.settings.botCount;
        }
        dom.playerNum.textContent = state.settings.playerCount;
        dom.botNum.textContent = state.settings.botCount;
        
        const currentCount = state.players.length;
        if (state.settings.playerCount > currentCount) {
            for(let i = currentCount; i < state.settings.playerCount; i++) {
                state.players.push({id: i + 1, name: '', photo: null});
            }
        } else if (state.settings.playerCount < currentCount) {
            state.players.splice(state.settings.playerCount);
        }
        renderPlayerSetup();
    };

    dom.minus.onclick = ()=>{ state.settings.playerCount = clamp(state.settings.playerCount - 1, 0, state.maxPlayers); updateTotalPlayerCount(); };
    dom.plus.onclick  = ()=>{ state.settings.playerCount = clamp(state.settings.playerCount + 1, 0, state.maxPlayers); updateTotalPlayerCount(); };
    dom.minusBot.onclick = ()=>{ state.settings.botCount = clamp(state.settings.botCount - 1, 0, state.maxPlayers); updateTotalPlayerCount(); };
    dom.plusBot.onclick  = ()=>{ state.settings.botCount = clamp(state.settings.botCount + 1, 0, state.maxPlayers); updateTotalPlayerCount(); };

    ['sound', 'innocent', 'jester', 'agentBlanc'].forEach(key => {
        const domKey = `option${key.charAt(0).toUpperCase() + key.slice(1)}`;
        const el = dom[domKey];
        if (!el) return;
        el.onclick = () => {
            state.settings[key] = !state.settings[key];
            if(key==='sound' && state.settings.sound) { initAudio(); sounds.click(); }
            updateOptionCards();
        };
    });
    ['classic', 'dynamic', 'revolution', 'fast'].forEach(mode => {
        const modeEl = dom[`mode${mode.charAt(0).toUpperCase() + mode.slice(1)}`];
        if (modeEl) {
            modeEl.onclick = () => {
                state.settings.gameMode = mode;
                updateOptionCards();
            };
        }
    });
  }

  // ---------- GAME FLOW ----------
  function startGame(isNewWord = false){
    const { playerCount, botCount, undercoverCount, innocent, jester, agentBlanc } = state.settings;
    const n = playerCount + botCount;
    if (n < state.minPlayers) { showModal({title:"Pas assez de joueurs", message:`Il faut au moins ${state.minPlayers} agents au total (humains + bots).`, buttons:[{text:"OK"}]}); return; }
    
    const U = (n < 4) ? 1 : undercoverCount;
    const I = (n < 3) ? 0 : (innocent ? 1 : 0);
    const J = (n < 4) ? 0 : (jester ? 1 : 0);
    const AB = (n < 4) ? 0 : (agentBlanc ? 1 : 0);
    const civils = n - U - I - J - AB;

    if (civils < 1){ showModal({title:"Configuration invalide", message:"Configuration de rôles impossible. Essayez avec plus de joueurs ou moins de rôles spéciaux.", buttons:[{text:"OK"}]}); return; }
    
    sounds.start();
    state.round = 1; state.distributionIndex = 0; state.lastSuspect = null; state._currentEvent = null;

    let themeKey = state.settings.theme;
    if (themeKey === 'random') {
        const themeKeys = Object.keys(THEME_DATA);
        themeKey = themeKeys[rand(themeKeys.length)];
    }
    let list = THEME_DATA[themeKey];
    state.wordPair = list[rand(list.length)];

    const oldPlayers = isNewWord ? state.players.filter(p => !p.isBot) : [];
    const humanPlayersToSave = [];
    state.players = [];
    const botNames = shuffle(["Alpha", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot", "Golf", "Hotel", "India", "Juliett", "Kilo", "Lima"]);
    if (setupAgentNames.length < playerCount) setupAgentNames = shuffle([...RANDOM_AGENT_NAMES]);
    
    for(let i=0; i<playerCount; i++) {
        const existingPlayer = isNewWord && oldPlayers[i] ? oldPlayers[i] : (state.players[i] || {});
        const name = (document.querySelector(`#playersSetup input[data-idx="${i}"]`)?.value || '').trim() || existingPlayer.name || setupAgentNames.pop() || `Agent ${i+1}`;
        const photo = existingPlayer?.photo || null;
        state.players.push({ id: i+1, name, photo, isBot: false, alive: true });
        humanPlayersToSave.push({id: i+1, name, photo});
    }
    localStorage.setItem('undercoverPlayers', JSON.stringify(humanPlayersToSave));

    for(let i=0; i<botCount; i++) {
        state.players.push({ id: playerCount + i + 1, name: `Bot ${botNames[i]}`, photo: null, isBot: true, alive: true });
    }

    const p_ids = shuffle(state.players.map(p=>p.id));
    let assigned_roles = 0;
    for(let i=0; i<U; i++){ const p = byId(p_ids[i]); p.role='undercover'; p.word=state.wordPair.b; assigned_roles++; }
    if(I === 1 && p_ids.length > assigned_roles){ const p = byId(p_ids[assigned_roles]); p.role='innocent'; p.word = "???"; assigned_roles++; }
    if(J === 1 && p_ids.length > assigned_roles){ const p = byId(p_ids[assigned_roles]); p.role='jester'; p.word = "???"; assigned_roles++; }
    if(AB === 1 && p_ids.length > assigned_roles){ const p = byId(p_ids[assigned_roles]); p.role='agentBlanc'; p.word = "???"; assigned_roles++; }
    state.players.forEach(p => {
        if (!p.role) { p.role = 'civil'; p.word = state.wordPair.a; }
    });

    state._gameController = new GameController();
    
    if (playerCount > 0) {
        show('pass');
        renderRevealCard();
    } else { 
        state._gameController.startRound();
    }
  }

  function renderRevealCard(){
    dom.revealCard.classList.remove('flipped');
    const player = state.players.filter(p => !p.isBot)[state.distributionIndex];
    if (!player) return;
    dom.currentName.textContent = player.name;
    if (player.role === 'innocent') {
        dom.secretWord.textContent = "Vous êtes l'Innocent";
    } else if (player.role === 'jester') {
        dom.secretWord.textContent = "Vous êtes le Jester";
    } else if (player.role === 'agentBlanc') {
        dom.secretWord.textContent = "Vous êtes l'Agent Blanc";
    } else {
        dom.secretWord.textContent = player.word || "—";
    }
  }
  
  function nextPlayerReveal() {
      if (dom.revealCard.classList.contains('flipped')) {
          showModal({title: "Cachez votre mot !", message: "Retournez la carte avant de passer au joueur suivant.", buttons:[{text:"OK"}]});
          return;
      }
      sounds.click();
      
      const humanPlayers = state.players.filter(p => !p.isBot);
      const isLastPlayer = state.distributionIndex >= humanPlayers.length - 1;

      dom.revealCard.style.transition = 'transform .3s ease-in, opacity .3s ease-in';
      dom.revealCard.style.transform = 'translateX(150%)';
      dom.revealCard.style.opacity = '0';
      
      setTimeout(() => {
          if (isLastPlayer) {
              showModal({ title: "Mission activée !", message: "Tous les agents ont reçu leurs instructions. La phase de jeu commence.", buttons: [] });
              setTimeout(() => {
                  if (dom.modalTemplate.open) dom.modalTemplate.close();
                  state._gameController.startRound();
              }, 2000);
          } else {
              state.distributionIndex++;
              renderRevealCard();
              dom.revealCard.style.transition = 'none'; 
              dom.revealCard.style.transform = 'translateX(-150%)';
              void dom.revealCard.offsetWidth;
              dom.revealCard.style.transition = 'transform .3s ease-out, opacity .3s ease-out';
              dom.revealCard.style.transform = 'translateX(0)';
              dom.revealCard.style.opacity = '1';
              setTimeout(() => {
                  dom.revealCard.style.transition = '';
                  dom.revealCard.style.transform = '';
                  dom.revealCard.style.opacity = '';
              }, 300);
          }
      }, 300);
  }
  
  function eliminate(player){
    sounds.eliminate();
    player.alive = false; 
    state.lastEliminated = player;
    dom.revealTitle.textContent = `${player.name} est éliminé·e`;
    dom.revealPhoto.innerHTML = avatarHTML(player);
    let roleText = 'Rôle : Civil';
    if(player.role === 'undercover') roleText = 'Rôle : Undercover';
    if(player.role === 'innocent') roleText = 'Rôle : Innocent';
    if(player.role === 'jester') roleText = 'Rôle : Jester';
    if(player.role === 'agentBlanc') roleText = 'Rôle : Agent Blanc';
    dom.roleBadge.textContent = roleText;
    dom.revealedWord.innerHTML = player.word && player.role !== 'innocent' ? `Mot : <b>${player.word}</b>` : 'Ce joueur n\'avait pas de mot.';
    
    show('reveal');
  }

  function handlePostElimination() {
    const player = state.lastEliminated;
    if (player.role === 'jester') {
        endGame('jester');
        return;
    }
    if (player.role === 'innocent') {
        showModal({
            title: "L'Innocent a été découvert !", message: "Pour gagner, vous devez deviner le mot des <b>Civils</b>.",
            input: { placeholder: "Quel était le mot des Civils ?" },
            buttons: [{ text: "Valider", class: "warn", onClick: (guess) => {
                if(guess && guess.trim().toLowerCase() === state.wordPair.a.toLowerCase()) { endGame('innocent'); } 
                else { showModal({title:"Mauvaise réponse !", message:`Le mot des civils était "<b>${state.wordPair.a}</b>". La partie continue.`, buttons:[{text:"OK", onClick: checkVictory }]}); }
            }}]
        });
    } else {
        showLastWordScreen();
    }
  }

  function showLastWordScreen() {
    const player = state.lastEliminated;
    dom.lastwordPrompt.innerHTML = `<b>${player.name}</b>, avant de partir, désignez un joueur que vous trouvez suspect.`;
    const grid = dom.lastwordGrid;
    grid.innerHTML = '';
    alive().forEach((p, i) => {
        const card = document.createElement('div');
        card.className = 'player-vote-card';
        card.style.animation = `fadeInUp .4s ${i * 50}ms both`;
        card.innerHTML = `${avatarHTML(p)}<div class="name">${p.name}</div>`;
        card.onclick = () => {
            state.lastSuspect = p.id;
            sounds.click();
            checkVictory();
        };
        grid.appendChild(card);
    });
    show('lastword');
  }

  function checkVictory(){
    if (state._activeScreen === 'end') return;
    
    const u_alive = alive().filter(p => p.role === 'undercover');
    const ab_alive = alive().filter(p => p.role === 'agentBlanc');
    const non_undercovers_alive = alive().filter(p => p.role !== 'undercover');

    // Undercover win condition
    if(u_alive.length >= non_undercovers_alive.length){
        endGame('undercover');
        return;
    }

    // Civil / Agent Blanc win condition
    if(u_alive.length === 0) {
        // Undercovers are gone. Now it's between Civils and Agent Blanc (if present).
        if (ab_alive.length > 0) {
            const agent = ab_alive[0];
            showModal({
                title: `L'Agent Blanc a Survécu !`,
                message: `<b>${agent.name}</b>, tous les Undercover ont été éliminés. Pour remporter la victoire, vous devez maintenant deviner le mot des Civils !`,
                input: { placeholder: "Le mot des Civils..." },
                preventClose: true,
                buttons: [{ text: "Valider", class: "warn", onClick: (guess) => {
                    if(guess && guess.trim().toLowerCase() === state.wordPair.a.toLowerCase()) {
                        endGame('agentBlanc');
                    } else {
                        showModal({title:"Mauvaise réponse !", message:`Le mot des Civils était "<b>${state.wordPair.a}</b>". Les Civils remportent la partie !`, buttons:[{text:"OK", onClick: () => endGame('civils') }]});
                    }
                }}]
            });
        } else {
            // No Agent Blanc, Civils win normally.
            endGame('civils');
        }
        return;
    }
    
    // If no one has won, continue the game
    if (['reveal', 'lastword'].includes(state._activeScreen)) {
        actions.reveal[0].action();
    }
  }

  function endGame(winner){
    let banner = '', detail='';
    if(winner==='civils'){ banner='Victoire des Civils !'; detail='Les Undercover ont été démasqués.'; sounds.win(); }
    else if(winner==='innocent'){ banner='Victoire de l\'Innocent !'; detail='Il a deviné le mot des civils !'; sounds.win(); }
    else if(winner==='jester'){ banner='Victoire du Jester !'; detail='Le Jester a réussi à se faire éliminer !'; sounds.win(); }
    else if(winner==='agentBlanc'){ banner='Victoire de l\'Agent Blanc !'; detail='L\'Agent Blanc a démasqué les Civils !'; sounds.win(); }
    else { banner='Victoire des Undercover !'; detail='Ils ont atteint la parité ou sont les derniers en lice.'; sounds.lose(); }
    
    dom.winnerBanner.innerHTML = banner;
    const civils = state.players.filter(p=>p.role==='civil').map(p=>p.name).join(', ');
    const undercovers = state.players.filter(p=>p.role==='undercover').map(p=>p.name).join(', ');
    const innocent = state.players.find(p=>p.role==='innocent');
    const jester = state.players.find(p=>p.role==='jester');
    const agentBlanc = state.players.find(p=>p.role==='agentBlanc');
    
    let summaryHtml = `${detail}<br><br><b>Civils (${state.wordPair.a})</b>: ${civils || 'aucun'}<br><b>Undercover (${state.wordPair.b})</b>: ${undercovers || 'aucun'}`;
    if (innocent) summaryHtml += `<br><b>Innocent</b>: ${innocent.name}`;
    if (jester) summaryHtml += `<br><b>Jester</b>: ${jester.name}`;
    if (agentBlanc) summaryHtml += `<br><b>Agent Blanc</b>: ${agentBlanc.name}`;

    dom.summary.innerHTML = summaryHtml;
    
    if (Object.keys(state.lastVotes).length > 0) {
        dom.voteRevealContainer.style.display = 'block';
        dom.voteRevealDetails.innerHTML = '';
        Object.keys(state.lastVotes).forEach((voterId, i) => {
            const voter = byId(parseInt(voterId));
            const target = byId(state.lastVotes[voterId]);
            if(voter && target) {
                const isSuspect = state.lastSuspect === parseInt(voterId);
                const gridItem = document.createElement('div');
                gridItem.className = 'vote-reveal-grid';
                gridItem.style.animation = `fadeInUp .4s ${i * 75}ms both`;
                gridItem.innerHTML = `
                        <div class="vote-reveal-item"><div class="avatar">${avatarHTML(voter)}</div><div class="name">${voter.name}</div></div>
                        <div class="vote-arrow ${isSuspect ? 'suspect' : ''}">→</div>
                        <div class="vote-reveal-item"><div class="avatar">${avatarHTML(target)}</div><div class="name">${target.name}</div></div>
                    `;
                dom.voteRevealDetails.appendChild(gridItem);
            }
        });
    } else {
        dom.voteRevealContainer.style.display = 'none';
    }

    show('end');
  }
  
  // ---------- ACTION BAR & NAVIGATION ----------
  const actions = {
    pass: [{ text: 'Agent suivant →', action: nextPlayerReveal }],
    event: [{ text: 'Compris !', action: () => state._gameController.continueFromEvent() }],
    reveal: [{ text: 'Continuer', action: () => { 
        if(state._activeScreen === 'reveal') {
            handlePostElimination();
        } else {
            if(state._activeScreen !== 'end') { 
                state.round++; 
                if(state._gameController) state._gameController.startRound(); 
            }
        }
    }}],
    end: [{ text: 'Menu principal', class: 'ghost', flex: 1, action: () => { initSetup(); show('home', 'backward'); } }, { text: 'Rejouer', class: '', flex: 2, action: () => { state.players.forEach(p=>{ p.alive=true; }); startGame(true); }}]
  };

  function updateActionBar(screenId) {
      const bar = dom.actionBar;
      bar.innerHTML = '';
      
      if (screenId === 'setup') {
          bar.classList.add('visible');
          let i = 0;
          if (state.setupStep > 1) {
              const backBtn = document.createElement('button');
              backBtn.className = 'btn ghost';
              backBtn.textContent = '← Précédent';
              backBtn.onclick = () => showSetupStep(state.setupStep - 1, 'backward');
              backBtn.style.animation = `fadeInUp .4s ${i * 60}ms both`;
              i++;
              bar.appendChild(backBtn);
          }
          const nextBtn = document.createElement('button');
          nextBtn.className = 'btn';
          if (state.setupStep < 5) {
              nextBtn.textContent = 'Suivant →';
              nextBtn.onclick = () => showSetupStep(state.setupStep + 1, 'forward');
          } else {
              nextBtn.textContent = 'Lancer la mission';
              nextBtn.onclick = () => startGame(false);
          }
          nextBtn.style.animation = `fadeInUp .4s ${i * 60}ms both`;
          bar.appendChild(nextBtn);
          return;
      }

      const screenActions = actions[screenId];
      if (screenActions) {
          screenActions.forEach((config, i) => {
              const button = document.createElement('button');
              button.className = `btn ${config.class || ''}`;
              button.textContent = config.text;
              if (config.flex) button.style.flex = config.flex;
              button.onclick = config.action;
              button.style.animation = `fadeInUp .4s ${i * 60}ms both`;
              bar.appendChild(button);
          });
          bar.classList.add('visible');
      } else { bar.classList.remove('visible'); }
  }
  
  // ---------- RANDOM EVENTS ----------
  const randomEvents = [
    {
      id: 'doubleVote', title: 'Vote Double', icon: '🗳️🗳️',
      description: (p) => `<b>${p.name}</b>, votre vote comptera double lors de la prochaine élimination !`,
      effect: (p) => { p.doubleVote = true; }
    },
    {
      id: 'silence', title: 'Silence Radio', icon: '🤫',
      description: (p) => `<b>${p.name}</b>, vous n'avez pas le droit de parler jusqu'au prochain tour. Donnez votre indice en mimant !`,
      effect: (p) => { p.silenced = true; }
    },
    {
      id: 'oracle', title: 'L\'Oracle', icon: '🔮',
      description: (p1, p2) => `<b>${p1.name}</b>, vous avez une vision ! Vous savez maintenant que <b>${p2.name}</b> est <b>${p2.role}</b>.`,
      effect: (p1, p2) => { /* Purely informational for p1 */ }
    },
    {
      id: 'amnesia', title: 'Amnésie', icon: '😵',
      description: (p) => `<b>${p.name}</b>, vous oubliez votre mot pour ce tour ! Vous devrez le deviner grâce aux autres.`,
      effect: (p) => { p.amnesia = true; }
    },
    {
      id: 'paranoia', title: 'Paranoïa', icon: '👀',
      description: () => `Attention ! Tous les votes de ce tour seront révélés publiquement à la fin !`,
      effect: () => { state.paranoia = true; }
    },
    {
      id: 'revolution', title: 'Révolution !', icon: '💥',
      description: () => `REVOLUTION ! Tous les Civils deviennent Undercover, et vice-versa ! Vos mots sont échangés !`,
      effect: () => {
        state.players.forEach(p => {
          if (p.role === 'civil') { p.role = 'undercover'; p.word = state.wordPair.b; }
          else if (p.role === 'undercover') { p.role = 'civil'; p.word = state.wordPair.a; }
        });
      },
      modes: ['revolution']
    },
    {
      id: 'interrogation', title: 'Interrogatoire', icon: '🔍',
      description: (p1, p2) => `<b>${p1.name}</b> a mené un interrogatoire secret sur <b>${p2.name}</b>... L'information est cruciale.`,
      effect: (p1, p2) => {
        if (!p1.isBot) {
          const wordToShow = p2.role === 'innocent' || p2.role === 'jester' || p2.role === 'agentBlanc'
            ? "Cet agent n'a pas de mot."
            : p2.word;
          setTimeout(() => showModal({
            title: "Rapport d'Interrogatoire",
            message: `Le mot de <b>${p2.name}</b> est : <div class="word-big" style="margin-top:0.5rem;">${wordToShow}</div>`,
            buttons: [{text: "Compris"}]
          }), 500);
        }
      }
    },
    {
      id: 'motTabou', title: 'Mot Tabou', icon: '🚫',
      description: (word) => `Le mot "<b>${word}</b>" est TABOU ce tour. L'utiliser comme indice annulera votre vote !`,
      effect: (word) => {
        state.tabooWord = word.toLowerCase();
      }
    }
  ];

  function triggerRandomEvent() {
    const mode = state.settings.gameMode;
    if (mode === 'classic' || Math.random() > (mode === 'revolution' ? 0.7 : 0.4)) {
        state._gameController.continueFromEvent();
        return;
    }

    const availableEvents = randomEvents.filter(e => (!e.modes || e.modes.includes(mode)) && (e.id !== 'interrogation' || alive().length >= 2));
    if (availableEvents.length === 0) {
        state._gameController.continueFromEvent();
        return;
    }

    const event = availableEvents[rand(availableEvents.length)];
    state._currentEvent = event;
    const players = shuffle(alive());
    
    dom.eventIcon.textContent = event.icon;
    dom.eventTitle.textContent = event.title;
    
    // Single-player events
    const singlePlayerEvents = ['doubleVote', 'silence', 'amnesia'];
    // Two-player events
    const twoPlayerEvents = ['oracle', 'interrogation'];

    if (singlePlayerEvents.includes(event.id)) {
        const p1 = players[0];
        event.effect(p1);
        dom.eventDescription.innerHTML = event.description(p1);
    } else if (twoPlayerEvents.includes(event.id)) {
        const p1 = players[0];
        const p2 = players[1];
        event.effect(p1, p2);
        dom.eventDescription.innerHTML = event.description(p1, p2);
    } else if (event.id === 'motTabou') {
        const allHints = [...(state.wordPair.hintsA || []), ...(state.wordPair.hintsB || [])];
        const tabooWord = allHints.length > 0 ? allHints[rand(allHints.length)] : "mot";
        event.effect(tabooWord);
        dom.eventDescription.innerHTML = event.description(tabooWord);
    } else { // Global events like 'paranoia', 'revolution'
        event.effect();
        dom.eventDescription.innerHTML = event.description();
    }
    
    sounds.event();
    show('event');
  }

  // ---------- GAME CONTROLLER CLASS ----------
  class GameController {
    constructor() {
        this.turnOrder = [];
        this.turnIndex = 0;
        this.phase = 'hint';
        this.timerId = null;
        this.timeLeft = 0;
        this.votes = {};
        this.turnTimerDuration = state.settings.gameMode === 'fast' ? 10 : 20; // seconds
        this.voteTimerDuration = state.settings.gameMode === 'fast' ? 15 : 30; // seconds
    }

    cleanup() {
        if (this.timerId) clearInterval(this.timerId);
        this.timerId = null;
        dom.actionBar.innerHTML = '';
        dom.actionBar.classList.remove('visible');
    }

    startRound() {
        this.cleanup();
        state.players.forEach(p => { p.votes = 0; p.hintGiven = false; p.doubleVote = false; p.silenced = false; p.amnesia = false; p.voteDisabled = false; p.roundHints = []; });
        state.paranoia = false;
        state.tabooWord = null;
        this.votes = {};
        this.turnOrder = shuffle(alive());
        this.turnIndex = 0;
        
        triggerRandomEvent();
    }
    
    continueFromEvent() {
        this.phase = 'hint';
        show('game');
        this.nextTurn();
    }
    
    nextTurn() {
        if (this.timerId) clearInterval(this.timerId);
        
        const hintsGiven = this.turnOrder.filter(p => p.hintGiven).length;
        if (hintsGiven >= this.turnOrder.length) {
            this.startVotePhase();
            return;
        }
        
        let currentPlayer = this.turnOrder[this.turnIndex];
        while(currentPlayer.hintGiven) {
            this.turnIndex = (this.turnIndex + 1) % this.turnOrder.length;
            currentPlayer = this.turnOrder[this.turnIndex];
        }

        this.renderTurnDisplay(currentPlayer);
        dom.gameContentArea.innerHTML = `<div class="center"><p class="hint">Donnez un indice sur votre mot...</p></div>`;
        
        const mode = state.settings.gameMode;
        this.timeLeft = this.turnTimerDuration;
        this.timerId = setInterval(() => this.updateTurnTimer(currentPlayer), 1000);
        this.updateTurnTimer(currentPlayer);

        const actionBar = dom.actionBar;
        actionBar.innerHTML = '';
        
        if (currentPlayer.isBot) {
            setTimeout(() => {
                let hint = "Hmm...";
                const myHints = currentPlayer.role === 'civil' ? (state.wordPair.hintsA || []) : (state.wordPair.hintsB || []);
                const allGivenHints = state.players.flatMap(p => p.roundHints || []);

                let availableHints = myHints.filter(h => !allGivenHints.includes(h));
                if (availableHints.length === 0 && myHints.length > 0) {
                    // If all unique hints are used, just pick a random one from the original list
                    availableHints = myHints;
                }

                if (availableHints.length > 0) {
                    hint = availableHints[rand(availableHints.length)];
                } else {
                    // Fallback if no hints are defined
                    hint = currentPlayer.role === 'civil' ? "Piste" : "Indice";
                }

                this.processHint(currentPlayer, hint);
            }, rand(2000) + 1000);
        } else {
            const hintBtn = document.createElement('button');
            hintBtn.className = 'btn';
            
            if (mode === 'classic' || state.settings.botCount === 0) {
                hintBtn.textContent = "Indice Donné (oral)";
                hintBtn.onclick = () => this.processHint(currentPlayer, "(oral)");
            } else {
                hintBtn.textContent = "Donner l'indice";
                if (currentPlayer.silenced) hintBtn.textContent = "Mimer l'indice";
                hintBtn.onclick = () => {
                    showModal({
                        title: `Indice de ${currentPlayer.name}`, message: "Entrez votre indice (un seul mot).",
                        input: { placeholder: "Votre indice..." },
                        buttons: [
                            { text: "Annuler", class: "ghost" },
                            { text: "Valider", onClick: (hint) => { if (hint?.trim()) this.processHint(currentPlayer, hint.trim()); }}
                        ]
                    });
                };
            }
            actionBar.appendChild(hintBtn);
            actionBar.classList.add('visible');
        }
    }

    renderTurnDisplay(player) {
        dom.turnDisplay.style.display = 'flex';
        const timerHTML = `<div class="turn-player-avatar">${avatarHTML(player)}<svg class="turn-timer-ring" viewBox="0 0 36 36"><circle class="turn-timer-circle" cx="18" cy="18" r="15.9155" stroke-dasharray="100, 100" stroke-dashoffset="100"></circle></svg></div>`;
        dom.turnDisplay.innerHTML = `
            ${timerHTML}
            <div class="turn-player-name">Tour ${state.round} : Au tour de <b>${player.name}</b></div>
        `;
    }

    updateTurnTimer(player) {
        if (this.timeLeft <= 0) {
            clearInterval(this.timerId);
            this.processHint(player, "..."); // Player ran out of time
            return;
        }

        const progress = (this.timeLeft / this.turnTimerDuration) * 100;
        const circle = dom.turnDisplay.querySelector('.turn-timer-circle');
        if (circle) {
            circle.style.strokeDashoffset = 100 - progress;
            if (this.timeLeft <= 5) {
                circle.style.stroke = 'var(--danger)';
            } else {
                circle.style.stroke = 'var(--accent)';
            }
        }
        
        this.timeLeft--;
    }
    
    processHint(player, hint) {
        if (this.timerId) clearInterval(this.timerId);
        player.hintGiven = true;
        player.roundHints.push(hint);

        if (state.tabooWord && hint.toLowerCase().includes(state.tabooWord)) {
            showModal({title: "Mot Tabou !", message: `<b>${player.name}</b> a utilisé le mot tabou ! En pénélité, son vote sera annulé ce tour.`});
            player.voteDisabled = true;
        }

        dom.gameContentArea.innerHTML = `<p class="hint">${player.name} a donné l'indice :</p><div class="hint-text">"${hint}"</div>`;
        dom.actionBar.innerHTML = '';
        dom.actionBar.classList.remove('visible');
        
        this.turnIndex = (this.turnIndex + 1) % this.turnOrder.length;
        
        setTimeout(() => {
            this.nextTurn();
        }, 3000);
    }

    startVotePhase() {
        this.cleanup();
        this.phase = 'vote';
        show('game');
        dom.turnDisplay.style.display = 'none';
        
        this.timeLeft = this.voteTimerDuration;
        const timerDisplayHTML = `<div class="vote-timer-display">${this.timeLeft}</div>`;
        dom.gameContentArea.innerHTML = `
            <div style="text-align:center;">
                <h2>Vote Final !</h2>
                <p class="hint">Discutez et votez pour l'Undercover !</p>
                ${timerDisplayHTML}
            </div>
            <div class="player-grid-vote"></div>
        `;
        this.renderVoteGrid();
        this.timerId = setInterval(() => this.updateVoteTimer(), 1000);
        
        const actionBar = dom.actionBar;
        actionBar.innerHTML = '';
        const tallyBtn = document.createElement('button');
        tallyBtn.className = 'btn';
        tallyBtn.textContent = 'Terminer le vote';
        tallyBtn.onclick = () => this.tallyVotes();
        actionBar.appendChild(tallyBtn);
        actionBar.classList.add('visible');
    }

    updateVoteTimer() {
        if (this.timeLeft <= 0) {
            clearInterval(this.timerId);
            this.tallyVotes();
            return;
        }
        this.timeLeft--;
        const timerEl = dom.gameContentArea.querySelector('.vote-timer-display');
        if (timerEl) timerEl.textContent = this.timeLeft;
        sounds.tick(this.timeLeft <= 5);
    }
    
    renderVoteGrid() {
        const grid = dom.gameContentArea.querySelector('.player-grid-vote');
        if (!grid) return;
        grid.innerHTML = '';
        alive().forEach((player, i) => {
            const card = document.createElement('div');
            card.className = 'player-vote-card';
            card.dataset.playerId = player.id;
            card.style.animation = `fadeInUp .4s ${i * 50}ms both`;
            
            const voterIDs = Object.keys(this.votes).map(id => parseInt(id));
            const humanVoters = alive().filter(p => !p.isBot).map(p => p.id);
            const allHumansVoted = humanVoters.every(id => voterIDs.includes(id));

            if (allHumansVoted) {
                 card.classList.add('disabled');
            } else {
                 card.onclick = (e) => this.castVote(player, e.currentTarget);
            }
            
            let voteCount = 0;
            let votersList = [];
            Object.entries(this.votes).forEach(([voterId, voteData]) => {
                if (voteData.targetId === player.id) {
                    const voter = byId(parseInt(voterId));
                    if (voter) {
                        voteCount += voteData.isDouble ? 2 : 1;
                        votersList.push(voter.name + (voteData.isDouble ? ' (x2)' : ''));
                    }
                }
            });

            const voteDisplay = state.paranoia ? `<div class="votes-count" style="font-size:0.7rem; color: var(--muted);">${votersList.join(', ')}</div>` : '';
            card.innerHTML = `${avatarHTML(player)}<div class="name">${player.name}</div><div class="votes-count" style="font-weight:bold;">${'🗳️'.repeat(voteCount)}</div>${voteDisplay}`;
            grid.appendChild(card);
        });
    }

    castVote(target, cardElement) {
        const potentialVoters = alive().filter(p => !p.isBot && !this.votes[p.id] && !p.voteDisabled);
        if (potentialVoters.length === 0) {
            showModal({title:"Vote", message:"Tous les joueurs humains pouvant voter ont voté."});
            return;
        }

        let voterSelectionHTML = '';
        potentialVoters.forEach(v => {
            voterSelectionHTML += `<button class="btn ghost" data-voter-id="${v.id}" style="width:auto; flex-grow: 1;">${v.name}</button>`;
        });

        showModal({
            title: `Qui vote pour ${target.name} ?`,
            message: `<div class="row" style="justify-content: center; flex-wrap: wrap; gap: 0.5rem;">${voterSelectionHTML}</div>`,
            buttons: []
        });

        document.querySelectorAll('[data-voter-id]').forEach(button => {
            button.onclick = () => {
                const voterId = parseInt(button.dataset.voterId, 10);
                const voter = byId(voterId);
                if (voter && !this.votes[voter.id]) {
                    sounds.click();
                    this.votes[voter.id] = { targetId: target.id, isDouble: !!voter.doubleVote };
                    dom.modalTemplate.close();
                    this.renderVoteGrid();
                }
            }
        });
    }

    tallyVotes() {
        if(this.timerId) clearInterval(this.timerId);
        this.timerId = null;

        alive().filter(p => p.isBot).forEach(bot => {
            if(!this.votes[bot.id]) {
                const targetId = this.getBotVote(bot);
                if (targetId) {
                    this.votes[bot.id] = { targetId: targetId, isDouble: !!bot.doubleVote };
                } else {
                    // Fallback just in case getBotVote returns null
                    const targets = alive().filter(p => p.id !== bot.id);
                    if (targets.length > 0) this.votes[bot.id] = { targetId: targets[rand(targets.length)].id, isDouble: !!bot.doubleVote };
                }
            }
        });
        
        state.lastVotes = {};
        Object.entries(this.votes).forEach(([voterId, voteData]) => {
            state.lastVotes[voterId] = voteData.targetId;
        });

        const voteCounts = {};
        alive().forEach(p => voteCounts[p.id] = 0);
        Object.entries(this.votes).forEach(([voterId, voteData]) => {
            if (voteCounts[voteData.targetId] !== undefined) {
                 const voter = byId(parseInt(voterId));
                 voteCounts[voteData.targetId] += (voter && voter.doubleVote) ? 2 : 1;
            }
        });

        let maxVotes = -1;
        Object.values(voteCounts).forEach(c => { if(c > maxVotes) maxVotes = c; });

        if (maxVotes <= 0) {
            showModal({ title: "Aucun vote", message: "Personne n'est éliminé ce tour.", buttons: [{ text: "Tour suivant", onClick: checkVictory }] });
            return;
        }

        const mostVotedIds = Object.keys(voteCounts).filter(id => voteCounts[id] === maxVotes);

        if (mostVotedIds.length !== 1) {
            showModal({ title: "Égalité !", message: "Plusieurs joueurs ont reçu le même nombre de votes. Personne n'est éliminé.", buttons: [{ text: "Tour suivant", onClick: checkVictory }] });
        } else {
            const playerToEliminate = byId(parseInt(mostVotedIds[0], 10));
            eliminate(playerToEliminate);
        }
    }
  }

  GameController.prototype.getBotVote = function(bot) {
    const targets = alive().filter(p => p.id !== bot.id);
    if (targets.length === 0) return null;

    const civilHints = state.wordPair.hintsA || [];
    const undercoverHints = state.wordPair.hintsB || [];

    let suspects = [];
    let allies = []; // Players who seem to be on the same team

    if (bot.role === 'civil') {
        // Civil bot logic
        targets.forEach(p => {
            const p_hints = p.roundHints || [];
            if (p_hints.some(h => undercoverHints.includes(h))) {
                suspects.push(p); // This player gave a hint for the undercover word
            } else if (p_hints.some(h => civilHints.includes(h))) {
                allies.push(p); // This player gave a hint for the civil word
            }
        });

        if (suspects.length > 0) {
            // Vote for a suspect
            return suspects[rand(suspects.length)].id;
        }
        // No clear suspects, vote for someone who is not a clear ally
        const nonAllies = targets.filter(t => !allies.map(a => a.id).includes(t.id));
        if (nonAllies.length > 0) {
            return nonAllies[rand(nonAllies.length)].id;
        }

    } else if (bot.role === 'undercover') {
        // Undercover bot logic
        targets.forEach(p => {
            const p_hints = p.roundHints || [];
            if (p_hints.some(h => civilHints.includes(h))) {
                suspects.push(p); // This player gave a hint for the civil word, so they are a target
            } else if (p_hints.some(h => undercoverHints.includes(h))) {
                allies.push(p); // This player gave a hint for the undercover word
            }
        });

        if (suspects.length > 0) {
            // Vote for a "suspect" (a civil)
            return suspects[rand(suspects.length)].id;
        }
        // No clear civils to vote for, vote for someone who is not a clear ally
        const nonAllies = targets.filter(t => !allies.map(a => a.id).includes(t.id));
        if (nonAllies.length > 0) {
            return nonAllies[rand(nonAllies.length)].id;
        }
    }

    // Fallback for all cases: vote for a random player
    return targets[rand(targets.length)].id;
  };

  // ---------- INITIALIZATION ----------
  function init() {
    getDOMElements();
    initSetup();
    show('home');

    function createFloatingWord() {
      const titleContainer = document.querySelector('.title-container');
      if (!titleContainer) return;

      const words = ["Secret", "Agent", "Vote", "Civil", "Undercover", "Bluff", "Indice", "Mission", "Révolution"];
      const word = words[Math.floor(Math.random() * words.length)];

      const span = document.createElement('span');
      span.className = 'floating-word';
      span.textContent = word;

      const containerRect = titleContainer.getBoundingClientRect();
      const x = Math.random() * (containerRect.width * 1.4) - (containerRect.width * 0.2);
      const y = Math.random() * (containerRect.height * 1.6) - (containerRect.height * 0.3);

      span.style.left = `${x}px`;
      span.style.top = `${y}px`;
      span.style.animationDelay = `${Math.random() * 2}s`;

      titleContainer.appendChild(span);

      setTimeout(() => {
          span.remove();
      }, 5000);
    }
    
    // Start floating words effect if on home screen
    if (dom.screenHome.classList.contains('active')) {
        setInterval(createFloatingWord, 1200);
    }

    dom.startGameBtn.onclick = (e) => {
        sounds.click();

        // Confetti burst effect
        const btn = e.currentTarget;
        const rect = btn.getBoundingClientRect();
        const x = rect.left + rect.width / 2;
        const y = rect.top + rect.height / 2;

        for (let i = 0; i < 40; i++) {
            const particle = document.createElement('div');
            particle.className = 'confetti-particle';
            document.body.appendChild(particle);

            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 120 + 50;
            const targetX = Math.cos(angle) * distance;
            const targetY = Math.sin(angle) * distance;

            particle.style.left = `${x}px`;
            particle.style.top = `${y}px`;
            const randomColor = `hsl(${Math.random() * 360}, 90%, 65%)`;
            particle.style.backgroundColor = randomColor;
            particle.style.setProperty('--x', `${targetX}px`);
            particle.style.setProperty('--y', `${targetY}px`);

            setTimeout(() => particle.remove(), 900);
        }

        // Delay screen transition to let the effect play
        setTimeout(() => {
            show('setup');
        }, 150);
    };

    if (dom.tipsBtn) {
        dom.tipsBtn.onclick = () => {
            sounds.click();
            const randomTip = TIPS[rand(TIPS.length)];
            showModal({
                title: "💡 Astuce du Jeu",
                message: randomTip,
                buttons: [{text: "Super !"}]
            });
        };
    }

    dom.btnReset.onclick = () => showModal({ title: "Nouvelle partie ?", message: "Toute la progression sera perdue. Voulez-vous vraiment recommencer ?", buttons: [{ text: "Annuler", class: "ghost" }, { text: "Oui, recommencer", class: "danger", onClick: () => { initSetup(); show('home'); } }] });
    dom.btnHelp.onclick = () => showModal({ title: "Règles du jeu", message: `<p>La majorité (<b>Civils</b>) reçoit le mot A, la minorité (<b>Undercover</b>) le mot B. Personne ne connaît son rôle au début. Donnez des indices, puis votez pour éliminer un joueur.</p><p><b>Modes de jeu :</b><br><b>- Classique:</b> Jeu oral, sans timer ni événements.<br><b>- Dynamique:</b> Avec timer et événements aléatoires.<br><b>- Révolution:</b> Événements plus fréquents et intenses.</p><p><b>L'Innocent</b> : Ce joueur n'a aucun mot. S'il est éliminé, il doit deviner le mot des Civils pour gagner seul.</p><p><b>Victoire</b> : Les Civils gagnent quand il n’y a plus d’Undercover. Les Undercover gagnent quand ils sont aussi nombreux ou plus que les autres.</p>`, buttons: [{ text: "Compris !", class: "" }] });
    dom.btnNewWord.onclick = () => showModal({ title: "Nouveau mot ?", message: "Voulez-vous vraiment relancer une manche avec un nouveau mot et les mêmes joueurs ?", buttons: [{ text: "Annuler", class: "ghost" }, { text: "Oui, relancer", class: "warn", onClick: () => startGame(true) }] });

    dom.btnShowMyCard.onclick = () => {
        let currentPlayer, context = '';
        const gc = state._gameController;
        if (state._activeScreen === 'pass') {
            currentPlayer = state.players.filter(p => !p.isBot)[state.distributionIndex];
            context = 'de recevoir votre carte';
        } else if (gc && gc.phase === 'hint' && gc.turnOrder[gc.turnIndex]) {
            const turnPlayer = gc.turnOrder[gc.turnIndex];
            if (!turnPlayer.isBot) {
                currentPlayer = turnPlayer;
                context = 'de donner un indice';
            }
        }

        if (currentPlayer) {
            const wordToShow = currentPlayer.amnesia ? "?? (Amnésie)" : (currentPlayer.role === 'innocent' ? 'Vous êtes l\'Innocent' : currentPlayer.word);
            showModal({
                title: "Confirmation",
                message: `<b>${currentPlayer.name}</b>, est-ce bien votre tour ${context} ?`,
                buttons: [
                    { text: "Non", class: "ghost" },
                    { text: "Oui, montrer ma carte", class: "", onClick: () => {
                        showModal({
                            title: `Votre carte, ${currentPlayer.name}`,
                            message: `<div style="text-align:center;"><div class="word-big">${wordToShow}</div><p style="margin-top:1rem;">Rôle: <b>${currentPlayer.role}</b></p></div>`,
                            buttons: [{text: "Cacher"}]
                        })
                    }}
                ]
            });
        } else {
             showModal({ title: "Action impossible", message: "Vous ne pouvez voir une carte que pendant le tour d'un joueur humain.", buttons: [{text: "OK"}] });
        }
    };
    
    dom.revealCard.onclick = () => {
        dom.revealCard.classList.toggle('flipped');
        sounds.flip();
    };
  }

  document.addEventListener('DOMContentLoaded', init);

  // Particle effect initialization
  if (window.tsParticles) {
    tsParticles.load("tsparticles", {
      fpsLimit: 60,
      interactivity: {
        events: {
          onHover: {
            enable: true,
            mode: "repulse"
          },
          resize: true
        },
        modes: {
          repulse: {
            distance: 100,
            duration: 0.4
          }
        }
      },
      particles: {
        color: {
          value: "#ffffff"
        },
        links: {
          color: "#ffffff",
          distance: 150,
          enable: true,
          opacity: 0.1,
          width: 1
        },
        move: {
          direction: "none",
          enable: true,
          outModes: {
            default: "out"
          },
          random: false,
          speed: 1,
          straight: false
        },
        number: {
          density: {
            enable: true,
            area: 800
          },
          value: 80
        },
        opacity: {
          value: 0.1
        },
        shape: {
          type: "circle"
        },
        size: {
          value: { min: 1, max: 3 }
        }
      },
      detectRetina: true
    });
  }
})();
</script>
</body>
</html>
