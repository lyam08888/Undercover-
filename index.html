<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
<title>Undercover 3.0 - R√©volution</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
<meta name="theme-color" content="#0D1117">
<style>
  #tsparticles {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
  }
  :root{
    --bg: #0D1117;
    --surface: #161B22;
    --surface-light: #2c333d;
    --border: #30363d;
    --ink: #e6edf3;
    --muted: #8b949e;
    --accent: #38BDF8;
    --accent-glow: rgba(56, 189, 248, 0.3);
    --danger: #F472B6;
    --warn: #FBBF24;
    --success: #34D399;
    --r: 12px;
  }
  *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
  html,body{height:100%; overflow: hidden;}
  body{
    margin:0; font-family: 'Inter', sans-serif;
    color:var(--ink);
    background-color: var(--bg);
    background-image: radial-gradient(circle at 10% 10%, var(--accent-glow), transparent 40%), radial-gradient(circle at 90% 90%, rgba(244, 114, 182, 0.1), transparent 40%);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    display: grid;
    place-items: center;
  }
  .app{
    width: 100%;
    height: 100vh; /* Use viewport height to solve mobile screen issue */
    display:flex;
    flex-direction:column; 
    position: relative; 
    background: var(--bg);
    overflow: hidden;
  }
  header{position:sticky;top:0;z-index:10;background: rgba(13, 17, 23, 0.7);
    backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
    border-bottom:1px solid var(--border); display: none;}
  .bar{display:flex;align-items:center;gap:.75rem;padding:.75rem 1rem; height: 60px;}
  .title{font-weight:800; font-size:1.1rem;}
  .spacer{flex:1}
  .icon-btn{background: transparent; border:none; color:var(--muted); padding:.5rem; border-radius:50%; display:inline-flex;align-items:center; cursor:pointer; transition: all .2s ease;}
  .icon-btn:hover, .icon-btn:focus { color:var(--ink); background: var(--surface); }
  main{flex:1; display:flex;flex-direction:column; overflow: hidden; position: relative;}
  .screen{position:absolute; top:0; left:0; width:100%; height:100%; display:flex; flex-direction:column; padding:1rem; overflow-y:auto; opacity:0; visibility:hidden; animation-fill-mode: both; pointer-events: none; z-index: 1;}
  .screen.active{opacity:1; visibility:visible; pointer-events: auto; z-index: 2;}
  .screen.slide-out { animation: slideOut .3s ease-out forwards; }
  .screen.slide-in { animation: slideIn .3s ease-in forwards; }
  .card{background:var(--surface); border-radius:var(--r); padding:1.2rem; border: 1px solid var(--border); animation: fadeInUp .4s .1s both; display: flex; flex-direction: column; flex: 1;}
  h1{font-size:1.5rem;margin:0 0 1rem 0; font-weight: 800; color: var(--accent); display: flex; align-items: center; gap: 0.5rem;}
  h2{font-size:1.1rem;margin:1.5rem 0 .75rem 0;color:var(--muted); font-weight: 700;}
  .row{display:flex;gap:.75rem;align-items:center;flex-wrap:wrap}
  input[type="text"], select{width:100%; padding:.75rem 1rem; font-size:1rem; color:var(--ink); background:var(--bg); border:1px solid var(--border); border-radius:8px; outline:none; transition: all .2s ease;}
  input[type="text"]:focus, select:focus {border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-glow);}
  .pill{display:flex; align-items:center; justify-content:space-between; gap:.75rem; padding:.75rem 1rem; border-radius:8px; border:1px solid var(--border); background:var(--bg);}
  .numstep{display:flex;align-items:center;gap:.55rem}
  .step-btn{width:40px;height:40px;border-radius:8px;border:1px solid var(--border); background:var(--surface-light); color:var(--ink); font-size:1.25rem; font-weight:600; cursor:pointer; transition: all .2s ease;}
  .step-btn:hover { border-color: var(--accent); }
  .counter{min-width:40px;text-align:center;font-weight:700;font-size:1.25rem}
  .btn{width:100%; padding:1rem 1.1rem; border-radius:8px; font-weight:700; border:none; color:var(--bg); background:var(--accent); font-size:1rem; cursor:pointer; transition: all .2s ease; -webkit-tap-highlight-color: transparent;}
  .btn:hover { filter: brightness(1.1); }
  .btn:active { transform: scale(0.98); }
  .btn.ghost{background:var(--surface-light); color:var(--ink); border:1px solid var(--border);}
  .btn.ghost:hover{border-color:var(--muted);}
  .btn.danger{background:var(--danger); color: #fff;}
  .players{display:flex;flex-direction:column; gap:.6rem}
  .player-row{display:flex; align-items:center; gap:.7rem; padding:.5rem; border-radius:8px; background: var(--surface-light);}
  .avatar{width:48px;height:48px;border-radius:8px;display:grid;place-items:center;font-weight:700; background:var(--bg); color:var(--muted); overflow:hidden; position:relative; flex-shrink: 0;}
  .avatar img{width:100%;height:100%;object-fit:cover;display:block}
  .center{display:grid;place-items:center; flex: 1; text-align: center;}
  .hint{font-size:.9rem;color:var(--muted); line-height: 1.5; max-width: 40ch; margin: 0 auto;}
  dialog{ border:none; border-radius:var(--r); background: var(--surface); color:var(--ink); padding:0; box-shadow:0 25px 50px -12px rgba(0,0,0,0.5); width:min(92vw,420px); border: 1px solid var(--border);}
  dialog::backdrop{background:rgba(0,0,0,.6); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);}
  dialog[open]{animation: zoomIn .2s ease-out;}
  @keyframes zoomIn {from{opacity:0; transform:scale(.95)}}
  .modal{padding:1.5rem}
  .modal h2 {margin:0 0 .5rem 0; font-weight: 700; font-size: 1.25rem; color: var(--accent);}
  .modal p {margin:.5rem 0 1.5rem 0; color: var(--muted); line-height: 1.6;}
  .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0; }

  .tip-box {
    font-size: .85rem;
    color: var(--muted);
    background-color: var(--surface);
    padding: .75rem 1rem;
    border-radius: 8px;
    border: 1px solid var(--border);
    line-height: 1.5;
    text-align: center;
  }
  .tip-box::before {
    content: 'üí° Astuce : ';
    font-weight: 700;
    color: var(--accent);
  }

  /* Action Bar */
  .action-bar{ position: fixed; bottom: 0; left: 0; right: 0; z-index: 10; padding: .75rem; background: linear-gradient(180deg, transparent, var(--bg) 80%); display: none; max-width: 480px; margin: 0 auto; animation: slideUp .3s ease-out; }
  .action-bar.visible { display: flex; gap: .75rem; }
  @keyframes slideUp { from { transform: translateY(100%); } to { transform: translateY(0); } }

  /* Pass Screen */
  .pass-container { display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 1.5rem; flex: 1; user-select: none;}
  .reveal-card-wrapper { perspective: 1500px; }
  .reveal-card {
    width: 85vw;
    max-width: 300px;
    aspect-ratio: 5 / 7;
    border-radius: var(--r);
    background: linear-gradient(165deg, var(--surface), #21262d);
    cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center;
    padding: 1.5rem; text-align: center;
    transition: transform 0.6s cubic-bezier(0.22, 1, 0.36, 1), box-shadow .3s ease, opacity .3s ease-in-out;
    border: 1px solid var(--border);
    box-shadow: 0 0 2px rgba(0,0,0,0.2), 0 4px 12px rgba(0,0,0,0.3);
    position: relative;
    transform-style: preserve-3d;
  }
  .reveal-card .icon { font-size: 3rem; margin-bottom: 1rem; color: var(--accent); transition: transform .3s ease; }
  .reveal-card .text { font-weight: 600; font-size: 1rem; }
  .reveal-card.flipped { transform: rotateY(180deg); }
  .card-face { position: absolute; top:0; left:0; width:100%; height:100%; -webkit-backface-visibility: hidden; backface-visibility: hidden; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 1.5rem; }
  .card-back { transform: rotateY(180deg); }
  .word-big { font-size: 2rem; font-weight: 800; color: var(--accent); }
  
  /* Game Screen */
  .game-container { width: 100%; height: 100%; display: flex; flex-direction: column; }
  .turn-display { display: flex; flex-direction: column; align-items: center; gap: 1rem; padding: 1rem; background: var(--surface); border-radius: var(--r); margin-bottom: 1rem; animation: slideDown .5s both; text-align: center;}
  .turn-player-avatar { width: 60px; height: 60px; border-radius: 50%; position: relative; margin: 0 auto .5rem auto; }
  .turn-player-avatar .avatar { width: 100%; height: 100%; border-radius: 50%; }
  .turn-timer-ring { position: absolute; top: -5px; left: -5px; width: 70px; height: 70px; }
  .turn-timer-circle { stroke: var(--accent); stroke-width: 4; fill: transparent; transition: stroke-dashoffset 0.2s linear, stroke 0.3s; transform: rotate(-90deg); transform-origin: 50% 50%; }
  .turn-player-name { font-size: 1.1rem; font-weight: 700; }
  .game-content-area { flex: 1; display: grid; place-items: center; text-align: center; padding: 1rem; }
  .hint-text { font-size: 2.5rem; font-weight: 800; animation: fadeIn .5s ease; }
  .vote-timer-display { text-align: center; font-size: 3rem; font-weight: 800; color: var(--accent); animation: pulse 1s infinite; }
  .player-grid-vote { display: grid; grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); gap: 1rem; padding: 1rem 0; width: 100%;}
  .player-vote-card { display: flex; flex-direction: column; align-items: center; gap: .5rem; padding: 1rem; background: var(--surface); border-radius: var(--r); border: 2px solid transparent; cursor: pointer; transition: all .2s ease; }
  .player-vote-card:not(.disabled):hover { transform: translateY(-4px); border-color: var(--muted); }
  .player-vote-card.voted { border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-glow); transform: scale(1.05); }
  .player-vote-card .avatar { width: 64px; height: 64px; border-radius: 50%; }
  .player-vote-card .name { font-weight: 600; font-size: 0.9rem; }
  .player-vote-card.disabled { opacity: 0.6; cursor: not-allowed; }

  /* Setup Steps */
  .setup-step {
    position: absolute;
    top: 1rem;
    left: 1rem;
    right: 1rem;
    bottom: 1rem;
    overflow-y: auto;
    opacity: 0;
    visibility: hidden;
    display: flex;
    flex-direction: column;
  }
  .setup-step.active { opacity: 1; visibility: visible; }

  /* Setup Options */
  .option-card {
    display: flex; flex-direction: column; align-items: center; justify-content: center; gap: .5rem;
    padding: 1rem .5rem; background: var(--bg); border: 1px solid var(--border);
    border-radius: 8px; cursor: pointer; transition: all .2s ease; text-align: center;
    flex: 1;
  }
  .option-card.active { background: var(--surface-light); border-color: var(--accent); }
  .option-card .icon { font-size: 1.5rem; }
  .option-card .label { font-size: .9rem; font-weight: 600; }
  .option-card .value { font-size: .8rem; color: var(--muted); }

  .theme-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: .75rem; margin-top: 1rem; }
  .theme-card {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    padding: 0.8rem;
    text-align: center;
    border: 1px solid var(--border);
    border-radius: 12px;
    cursor: pointer;
    transition: all .2s ease;
    background: var(--bg); /* To contrast with parent .card */
    aspect-ratio: 1 / 1;
  }
  .theme-card:hover {
    transform: translateY(-3px);
    border-color: var(--accent);
  }
  .theme-card.active {
    background: var(--surface-light);
    border-color: var(--accent);
    box-shadow: 0 0 0 3px var(--accent-glow);
    transform: translateY(-3px);
  }
  .theme-card .icon {
    font-size: 1.5rem;
    line-height: 1;
    background: var(--surface);
    padding: .75rem;
    border-radius: 8px;
    display: grid;
    place-items: center;
  }
  .theme-card .label {
    font-size: .9rem;
    font-weight: 700;
    margin-top: 0;
  }

  /* Home Screen */
  .home-title {
    font-size: clamp(2rem, 10vw, 3.2rem);
    font-weight: 800;
    text-align: center;
    letter-spacing: -1.5px;
    background: linear-gradient(90deg, var(--accent), #fff, var(--danger), var(--accent));
    background-size: 300% auto;
    background-clip: text;
    -webkit-background-clip: text;
    color: transparent;
    animation: title-shimmer 6s linear infinite;
  }
  .home-title .accent { color: inherit; } /* Inherit the gradient */

  @keyframes title-shimmer {
    to {
        background-position: -300% center;
    }
  }

  .confetti-particle {
    position: fixed;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    pointer-events: none;
    opacity: 0;
    animation: confetti-burst 0.9s ease-out forwards;
  }

  @keyframes confetti-burst {
    0% { transform: scale(1); opacity: 1; }
    100% { transform: translate(var(--x), var(--y)) scale(0); opacity: 0; }
  }

  .floating-word {
    position: absolute;
    font-size: 1.2rem;
    font-weight: 600;
    color: var(--muted);
    opacity: 0;
    animation: float-and-fade 5s ease-in-out forwards;
    pointer-events: none;
    white-space: nowrap;
    z-index: 0;
  }

  @keyframes float-and-fade {
    0% { transform: translateY(20px) scale(0.8); opacity: 0; }
    20%, 80% { transform: translateY(-20px) scale(1); opacity: 0.6; }
    100% { transform: translateY(-60px) scale(0.7); opacity: 0; }
  }

  /* Vote Reveal */
  .vote-reveal-grid { display: grid; grid-template-columns: 1fr auto 1fr; align-items: center; gap: 1rem; margin-top: 1rem; padding: 0.5rem 0; border-bottom: 1px solid var(--border); }
  .vote-reveal-grid:last-child { border-bottom: none; }
  .vote-reveal-item { display: flex; flex-direction: column; align-items: center; gap: 0.5rem; text-align: center; }
  .vote-reveal-item .avatar { width: 56px; height: 56px; border-radius: 50%; }
  .vote-reveal-item .name { font-size: 0.9rem; font-weight: 600; }
  .vote-arrow { font-size: 2rem; color: var(--muted); }
  .vote-arrow.suspect { color: var(--danger); font-weight: bold; }
  
  /* Event Screen */
  #screen-event .center { gap: 1.5rem; }
  #event-icon { font-size: 4rem; animation: zoomIn .5s both; }
  #event-title { font-size: 2rem; animation: fadeInUp .5s .2s both; }
  #event-description { max-width: 45ch; animation: fadeInUp .5s .4s both; }
  
  /* Animations */
  @keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
  @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
  @keyframes slideDown { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
  @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
  @keyframes slideOut { to { opacity: 0; transform: translateX(-50%); visibility: hidden; } }
  @keyframes slideIn { from { opacity: 0; transform: translateX(50%); } to { opacity: 1; transform: translateX(0); visibility: visible;} }
  .reveal-avatar { animation: zoomIn .5s .1s both; }
  .reveal-title { animation: fadeInUp .5s .3s both; }
  .reveal-card-info { animation: fadeInUp .5s .5s both; }
  .winner-banner { animation: zoomIn .5s cubic-bezier(0.25, 2.5, 0.5, 1) both; }

  @keyframes title-glow {
    from { text-shadow: 0 0 10px var(--accent-glow), 0 0 20px var(--accent-glow); }
    to { text-shadow: 0 0 20px var(--accent-glow), 0 0 30px var(--accent-glow), 0 0 5px var(--accent); }
  }

  @keyframes slide-out-left { from { transform: translateX(0); opacity: 1; } to { transform: translateX(-100%); opacity: 0; } }
  @keyframes slide-in-right { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
  @keyframes slide-out-right { from { transform: translateX(0); opacity: 1; } to { transform: translateX(100%); opacity: 0; } }
  @keyframes slide-in-left { from { transform: translateX(-100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
  .slide-out-left { animation: slide-out-left 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards; }
  .slide-in-right { animation: slide-in-right 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards; }
  .slide-out-right { animation: slide-out-right 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards; }
  .slide-in-left { animation: slide-in-left 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards; }

  @media (min-width: 501px) {
    .app {
      max-width: 480px;
      height: 95vh;
      max-height: 900px;
      border-radius: 16px;
      box-shadow: 0 0 80px rgba(0,0,0,0.5);
    }
  }
</style>
<script src="https://cdn.jsdelivr.net/npm/tsparticles@3.4.0/tsparticles.bundle.min.js"></script>
</head>
<body>
<div id="tsparticles"></div>
<div class="app">
  <header id="game-header">
    <div class="bar">
      <div class="title">Undercover 3.0</div>
      <div class="spacer"></div>
      <button id="btnShowMyCard" class="icon-btn" title="Voir ma carte" style="display: none;"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></svg></button>
      <button id="btnNewWord" class="icon-btn" title="Nouveau mot" style="display: none;"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/></svg></button>
      <button id="btnReset" class="icon-btn" title="Nouvelle partie"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 1 1-6.219-8.56"/></svg></button>
      <button id="btnHelp" class="icon-btn" title="R√®gles"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><path d="M12 17h.01"/></svg></button>
    </div>
  </header>

  <main>
    <!-- HOME -->
    <section id="screen-home" class="screen active">
    <div class="center" style="display: flex; flex-direction: column; justify-content: space-around; align-items: center; padding: 3rem 1rem;">
            <div class="title-container" style="position: relative; z-index: 1;">
              <h1 class="home-title" style="animation: fadeInUp .5s .1s both;">Undercover<span class="accent"> 3.0</span></h1>
            </div>
        <div style="animation: fadeInUp .5s .3s both; display: flex; flex-direction: column; gap: .75rem; width: 80%; max-width: 300px;">
                <button id="start-game-btn" class="btn" style="width: 100%; padding: 1rem 2rem;">Commencer √† jouer</button>
            </div>
        <div class="tip-box" style="animation: fadeInUp .5s .5s both; max-width: 380px;">Le but est simple : les Civils doivent d√©masquer les Undercover, et les Undercover doivent survivre !</div>
        </div>
    </section>

    <!-- SETUP -->
    <section id="screen-setup" class="screen">
        <!-- Step 1: Mode -->
        <div class="setup-step active" data-step="1">
            <div class="card">
                <h1><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>Mode de Jeu</h1>
                <div class="row" style="margin-top: 1rem;">
                    <div id="mode-classic" class="option-card"><div class="icon">‚òï</div><div class="label">Classique</div><div class="value">Oral, avec timer</div></div>
                    <div id="mode-dynamic" class="option-card active"><div class="icon">‚ö°</div><div class="label">Dynamique</div><div class="value">Timer & √âv√©nements</div></div>
                    <div id="mode-revolution" class="option-card"><div class="icon">üí•</div><div class="label">R√©volution</div><div class="value">√âv√©nements intenses</div></div>
                    <div id="mode-fast" class="option-card"><div class="icon">‚è±Ô∏è</div><div class="label">Rapide</div><div class="value">Timers courts</div></div>
                </div>
            </div>
        </div>
        <!-- Step 2: Mission -->
        <div class="setup-step" data-step="2">
            <div class="card">
                <h1><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2.5 17a2.4 2.4 0 0 1 3 0L8 20l3-3a2.4 2.4 0 0 1 3 0L19.5 20a2.4 2.4 0 0 1 0-3L17 15l3-3a2.4 2.4 0 0 0 0-3L15 4l-3 3a2.4 2.4 0 0 0-3 0L4 4a2.4 2.4 0 0 0 0 3l3 3-2.5 2.5a2.4 2.4 0 0 0 0 3Z"/></svg>Choisissez un th√®me</h1>
                <div id="theme-grid" style="margin-top: 1rem; flex: 1;"></div>
            </div>
        </div>
        <!-- Step 3: Agents -->
        <div class="setup-step" data-step="3">
            <div class="card">
                <h1><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>Param√©trez les agents</h1>
                <div class="row" style="margin-top:1rem"><div class="pill" style="flex:1.5"><span><b>Agents Humains</b> (0‚Äì12)</span><div class="numstep"><button id="minus" class="step-btn">‚àí</button><div id="playerNum" class="counter">4</div><button id="plus" class="step-btn">+</button></div></div><div class="pill" style="flex:1"><span>Bots IA</span><div class="numstep"><button id="minusBot" class="step-btn">‚àí</button><div id="botNum" class="counter">0</div><button id="plusBot" class="step-btn">+</button></div></div></div>
                <p class="hint" style="margin-top: auto; text-align: center; padding-top: 1rem;">Le nombre total d'agents (humains + bots) doit √™tre entre 3 et 12.</p>
            </div>
        </div>
        <!-- Step 4: Options -->
        <div class="setup-step" data-step="4">
            <div class="card">
                <h1 style="font-size: 1.25rem;"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 0 2l-.15.08a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l-.22-.38a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1 0-2l.15-.08a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>Options de la partie</h1>
                <div class="setup-options" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); gap: .75rem; align-content: center; flex: 1;">
                    <div id="option-sound" class="option-card"><div class="icon">üîä</div><div class="label">Sons</div><div class="value">D√©sactiv√©</div></div>
                    <div id="option-innocent" class="option-card"><div class="icon">üòá</div><div class="label">Innocent</div><div class="value">D√©sactiv√©</div></div>
                    <div id="option-jester" class="option-card"><div class="icon">üÉè</div><div class="label">Jester</div><div class="value">D√©sactiv√©</div></div>
                    <div id="option-agent-blanc" class="option-card"><div class="icon">üïµÔ∏è</div><div class="label">Agent Blanc</div><div class="value">D√©sactiv√©</div></div>
                </div>
            </div>
        </div>
        <!-- Step 5: Players -->
        <div class="setup-step" data-step="5">
            <div class="card">
                <h1 style="font-size: 1.25rem;"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>Agents Humains</h1>
                <div id="playersSetup" class="players" style="flex: 1; overflow-y: auto;"></div>
            </div>
        </div>
    </section>

    <!-- PASS & CARD REVEAL -->
    <section id="screen-pass" class="screen">
        <div class="pass-container">
            <div style="text-align:center;"><h1>Passez √† <b id="currentName"></b></h1><p class="hint">Touchez la carte pour r√©v√©ler votre r√¥le secret. <br>Cachez-la avant de passer au suivant.</p></div>
            <div class="reveal-card-wrapper"><div id="revealCard" class="reveal-card"><div class="card-face card-front"><div class="icon">?</div><div class="text">TOUCHER POUR R√âV√âLER</div></div><div class="card-face card-back"><div id="secretWord" class="word-big"></div></div></div></div>
        </div>
    </section>

    <!-- GAME ROUND -->
    <section id="screen-game" class="screen">
        <div class="game-container">
            <div id="turn-display" class="turn-display"></div>
            <div id="game-content-area" class="game-content-area"></div>
            <div class="tip-box" style="margin: 0 1rem 1rem 1rem;">Observez les r√©actions des autres apr√®s chaque indice. Une h√©sitation peut √™tre r√©v√©latrice.</div>
        </div>
    </section>
    
    <!-- EVENT -->
    <section id="screen-event" class="screen">
        <div class="center">
            <div id="event-icon"></div>
            <h1 id="event-title"></h1>
            <p id="event-description" class="hint"></p>
            <div class="tip-box" style="margin-top: 2rem;">Les √©v√©nements peuvent retourner la situation. Utilisez-les √† votre avantage !</div>
        </div>
    </section>

    <!-- REVEAL / RESULT -->
    <section id="screen-reveal" class="screen">
      <div class="center" style="gap:.8rem;"><div id="revealPhoto" class="avatar reveal-avatar" style="width:120px;height:120px;border-radius:50%;"></div><h1 id="revealTitle" class="reveal-title" style="margin-top: 1rem;"></h1><div class="card reveal-card-info" style="max-width:400px; width: 100%;"><div id="roleBadge" style="font-weight: 600; color: var(--muted); margin-bottom: .5rem;">R√¥le</div><div id="revealedWord" style="font-size: 1.2rem; font-weight: 700;"></div></div>
      <div class="tip-box" style="margin-top: 1.5rem;">Si un Civil est √©limin√©, les Undercover gagnent du terrain. S'il s'agissait d'un Undercover, vous √™tes plus proches de la victoire !</div></div>
    </section>
    
    <!-- LAST WORD -->
    <section id="screen-lastword" class="screen">
        <div class="center" style="gap: 1rem;">
            <h1>Dernier Mot</h1>
            <p class="hint" id="lastword-prompt"></p>
            <div id="lastword-grid" class="player-grid-vote"></div>
            <div class="tip-box">Votre "dernier mot" peut influencer le prochain vote. Choisissez judicieusement !</div>
        </div>
    </section>

    <!-- END -->
    <section id="screen-end" class="screen">
      <div class="center" style="gap:.8rem;"><h1 id="winnerBanner" class="winner-banner" style="font-size: 2.5rem;"></h1><p id="summary" class="hint" style="max-width: 400px; animation: fadeInUp .5s .2s both;"></p>
      <div id="vote-reveal-container" class="card" style="width: 100%; max-width: 400px; display:none; animation: fadeInUp .5s .4s both;">
        <h2>Qui a vot√© contre qui ?</h2>
        <div id="vote-reveal-details"></div>
      </div>
      <div class="tip-box" style="animation: fadeInUp .5s .6s both;">Chaque partie est diff√©rente. Essayez de nouvelles strat√©gies, de nouveaux th√®mes et de nouveaux r√¥les !</div>
      </div>
    </section>
  </main>

  <div id="actionBar" class="action-bar"></div>
</div>

<!-- Modals -->
<dialog id="modal-template">
    <div class="modal"><h2 id="modal-title"></h2><p id="modal-message"></p><div id="modal-input-wrap" style="display:none;"><input type="text" id="modal-input" style="width: 100%;"></div><div id="modal-actions" class="row" style="margin-top:1.5rem"></div></div>
</dialog>

<script>
(function(){
  // ---------- WORD DATA V4 ----------
  const THEME_DATA = {
    "Culture Pop": [
      {a:"Pok√©mon",b:"Digimon", hintsA:["capture", "pok√©ball", "ar√®ne"], hintsB:["digital", "monde", "donn√©es"]},
      {a:"Marvel",b:"DC Comics", hintsA:["iron man", "avengers", "cin√©ma"], hintsB:["batman", "justice league", "sombre"]},
      {a:"Harry Potter",b:"Seigneur des Anneaux", hintsA:["baguette", "sorcier", "√©cole"], hintsB:["anneau", "communaut√©", "qu√™te"]},
      {a:"Twitch",b:"YouTube", hintsA:["stream", "emote", "abonnement"], hintsB:["vid√©o", "cha√Æne", "playlist"]},
      {a:"Star Wars", b:"Star Trek", hintsA:["force", "sabre laser", "jedi"], hintsB:["f√©d√©ration", "vaisseau", "exploration"]},
      {a:"Mario",b:"Sonic", hintsA:["plombier", "champignon", "princesse"], hintsB:["h√©risson", "vitesse", "anneaux"]},
      {a:"Fortnite",b:"Minecraft", hintsA:["battle royale", "construction", "skin"], hintsB:["blocs", "crafting", "survie"]},
      {a:"Netflix",b:"Disney+", hintsA:["streaming", "s√©rie", "binge"], hintsB:["streaming", "famille", "mickey"]},
    ],
    "Vie Quotidienne": [
      {a:"Pull",b:"Gilet", hintsA:["laine", "manches", "col"], hintsB:["boutons", "sans manches", "cardigan"]},
      {a:"Caf√©",b:"Th√©", hintsA:["machine", "expresso", "arabica"], hintsB:["infusion", "sachet", "bouilloire"]},
      {a:"Fourchette",b:"Cuill√®re", hintsA:["piquer", "dents", "couvert"], hintsB:["contenir", "soupe", "ronde"]},
      {a:"Chaussette",b:"Collant", hintsA:["pied", "paire", "coton"], hintsB:["jambe", "nylon", "robe"]},
      {a:"Livre",b:"Magazine", hintsA:["chapitres", "roman", "auteur"], hintsB:["articles", "photos", "hebdomadaire"]},
      {a:"Bus", b:"M√©tro", hintsA:["arr√™t", "surface", "ville"], hintsB:["station", "souterrain", "rail"]},
      {a:"T-shirt",b:"Chemise", hintsA:["coton", "manches courtes", "d√©contract√©"], hintsB:["col", "boutons", "formel"]},
    ],
    "Gastronomie": [
      {a:"Baguette",b:"Croissant", hintsA:["longue", "sal√©e", "pain"], hintsB:["viennoiserie", "beurre", "sucr√©"]},
      {a:"Camembert",b:"Roquefort", hintsA:["vache", "normandie", "croute"], hintsB:["brebis", "bleu", "cave"]},
      {a:"Raclette",b:"Fondue", hintsA:["pomme de terre", "fromage fondu", "charcuterie"], hintsB:["pain", "fromage fondu", "caquelon"]},
      {a:"Sel",b:"Poivre", hintsA:["blanc", "cristal", "mer"], hintsB:["noir", "grain", "√©pice"]},
      {a:"Vin rouge",b:"Vin blanc", hintsA:["viande", "tannin", "sombre"], hintsB:["poisson", "sec", "clair"]},
    ],
    "Culture G & Arts": [
        {a:"Tour Eiffel",b:"Arc de Triomphe", hintsA:["fer", "champs de mars", "antenne"], hintsB:["pierre", "√©toile", "tombe"]},
        {a:"Moli√®re",b:"Victor Hugo", hintsA:["th√©√¢tre", "com√©die", "farce"], hintsB:["roman", "po√©sie", "mis√©rables"]},
        {a:"Peinture",b:"Sculpture", hintsA:["toile", "pinceau", "couleur"], hintsB:["volume", "marbre", "statue"]},
        {a:"Joconde",b:"Cri", hintsA:["sourire", "da vinci", "louvre"], hintsB:["angoisse", "munch", "pont"]},
        {a:"Mozart",b:"Beethoven", hintsA:["prodige", "op√©ra", "autriche"], hintsB:["sourd", "symphonie", "allemagne"]},
    ],
    "Lieux & Voyages": [
        {a:"Paris",b:"Londres", hintsA:["seine", "capitale", "france"], hintsB:["tamise", "capitale", "angleterre"]},
        {a:"Alpes",b:"Pyr√©n√©es", hintsA:["mont blanc", "ski", "haute"], hintsB:["fronti√®re", "espagne", "cha√Æne"]},
        {a:"Japon",b:"Chine", hintsA:["sushi", "tokyo", "√Æle"], hintsB:["muraille", "p√©kin", "continent"]},
        {a:"Plage",b:"Montagne", hintsA:["sable", "mer", "vague"], hintsB:["neige", "sommet", "rocher"]},
        {a:"D√©sert",b:"For√™t", hintsA:["chaud", "sable", "cactus"], hintsB:["humide", "arbres", "verdure"]},
    ],
    "Animaux & Nature": [
      {a:"Chat",b:"Chien", hintsA:["f√©lin", "ind√©pendant", "griffes"], hintsB:["canin", "fid√®le", "aboie"]},
      {a:"Lion",b:"Tigre", hintsA:["savane", "roi", "crini√®re"], hintsB:["jungle", "rayures", "solitaire"]},
      {a:"Abeille",b:"Gu√™pe", hintsA:["miel", "ruche", "pollen"], hintsB:["dard", "agressive", "jaune"]},
      {a:"Rose",b:"Tulipe", hintsA:["√©pines", "rouge", "fleur"], hintsB:["bulbe", "hollande", "p√©tale"]},
      {a:"Soleil",b:"Lune", hintsA:["jour", "√©toile", "chaleur"], hintsB:["nuit", "satellite", "lumi√®re"]},
    ],
    "Science & Tech": [
      {a:"Apple",b:"Microsoft", hintsA:["iphone", "mac", "design"], hintsB:["windows", "office", "logiciel"]},
      {a:"ADN",b:"ARN", hintsA:["double h√©lice", "g√©n√©tique", "chromosome"], hintsB:["simple brin", "messager", "transcription"]},
      {a:"Voiture √©lectrique",b:"Voiture thermique", hintsA:["batterie", "recharge", "silence"], hintsB:["essence", "moteur", "pollution"]},
      {a:"Astronaute",b:"Cosmonaute", hintsA:["nasa", "am√©ricain", "espace"], hintsB:["roscosmos", "russe", "espace"]},
    ],
    "Sport": [
      {a:"Football",b:"Rugby", hintsA:["rond", "pied", "but"], hintsB:["ovale", "main", "essai"]},
      {a:"Tennis",b:"Badminton", hintsA:["raquette", "balle", "filet"], hintsB:["raquette", "volant", "l√©ger"]},
      {a:"Formule 1",b:"Rallye", hintsA:["circuit", "rapide", "monoplace"], hintsB:["sp√©ciale", "d√©rapage", "copilote"]},
      {a:"Judo",b:"Karat√©", hintsA:["prise", "tatami", "souplesse"], hintsB:["frappe", "dojo", "kata"]},
      {a:"Piscine",b:"Patinoire", hintsA:["eau", "nager", "maillot"], hintsB:["glace", "patiner", "froid"]},
    ],
    "Culture Alg√©rienne": [
      {a:"Chorba",b:"Hrira", hintsA:["vermicelles", "soupe", "ramadan"], hintsB:["l√©gumineuses", "soupe", "maroc"]},
      {a:"Couscous",b:"Berkoukes", hintsA:["fin", "semoule", "l√©gumes"], hintsB:["gros", "plombs", "p√¢tes"]},
      {a:"Zlabia",b:"Makrout", hintsA:["friture", "miel", "sucr√©"], hintsB:["semoule", "datte", "g√¢teau"]},
      {a:"Th√© √† la menthe",b:"Caf√© maure", hintsA:["vert", "infusion", "maghreb"], hintsB:["noir", "turc", "serr√©"]},
    ],
    "Mots Pi√©g√©s & Absurdes": [
      {a:"Ornithorynque",b:"Pangolin", hintsA:["bec", "australie", "venin"], hintsB:["√©cailles", "fourmis", "roule"]},
      {a:"Schizophr√®ne",b:"Parano√Øaque", hintsA:["voix", "hallucination", "dissociation"], hintsB:["m√©fiance", "complot", "pers√©cution"]},
      {a:"Cl√©",b:"Serrure", hintsA:["tourne", "porte", "m√©tal"], hintsB:["re√ßoit", "trou", "verrou"]},
      {a:"Haut",b:"Bas", hintsA:["ciel", "dessus", "monter"], hintsB:["sol", "dessous", "descendre"]},
      {a:"Gauche",b:"Droite", hintsA:["politique", "main", "coeur"], hintsB:["politique", "main", "sens"]},
    ],
    "Histoire & Mythologie": [
      {a:"Jules C√©sar",b:"Alexandre le Grand", hintsA:["rome", "gaule", "empereur"], hintsB:["mac√©doine", "perse", "conqu√©rant"]},
      {a:"Cl√©op√¢tre",b:"N√©fertiti", hintsA:["reine", "√©gypte", "nil"], hintsB:["reine", "√©gypte", "beaut√©"]},
      {a:"Zeus",b:"Pos√©idon", hintsA:["ciel", "foudre", "olympe"], hintsB:["mer", "trident", "oc√©an"]},
      {a:"Lancelot",b:"Arthur", hintsA:["chevalier", "table ronde", "gueni√®vre"], hintsB:["roi", "excalibur", "camelot"]},
    ],
    "Marques C√©l√®bres": [
      {a:"Coca-Cola",b:"Pepsi", hintsA:["rouge", "boisson", "am√©ricain"], hintsB:["bleu", "boisson", "concurrent"]},
      {a:"Nike",b:"Adidas", hintsA:["swoosh", "chaussure", "sport"], hintsB:["trois bandes", "chaussure", "allemand"]},
      {a:"Google",b:"Facebook", hintsA:["recherche", "moteur", "android"], hintsB:["social", "profil", "meta"]},
      {a:"McDonald's",b:"Burger King", hintsA:["arches", "big mac", "clown"], hintsB:["flamme", "whopper", "roi"]},
    ],
    "Corps Humain": [
      {a:"Cerveau",b:"Coeur", hintsA:["pens√©e", "organe", "t√™te"], hintsB:["sang", "organe", "pompe"]},
      {a:"Main",b:"Pied", hintsA:["doigts", "saisir", "bras"], hintsB:["orteils", "marcher", "jambe"]},
      {a:"Oeil",b:"Oreille", hintsA:["vision", "regarder", "couleur"], hintsB:["audition", "√©couter", "son"]},
      {a:"Poumon",b:"Estomac", hintsA:["respiration", "air", "cage thoracique"], hintsB:["digestion", "nourriture", "acide"]},
    ]
  };
  const RANDOM_AGENT_NAMES = ["Spectre", "Vip√®re", "Corbeau", "Ombre", "Fant√¥me", "Loup", "Cobra", "Ph√©nix", "Tigre", "Faucon", "Mirage", "Zodiac"];
  const TIPS = [
    "En tant que Civil, donnez un indice pr√©cis mais pas trop √©vident pour ne pas aider l'Undercover.",
    "En tant qu'Undercover, essayez de vous fondre dans la masse. Votre premier indice est crucial !",
    "Si un r√¥le 'Innocent' est en jeu, il gagne s'il est √©limin√© ET devine le mot des Civils. Ne le sous-estimez pas !",
    "Observez les r√©actions des autres apr√®s chaque indice. Une h√©sitation peut √™tre r√©v√©latrice.",
    "N'h√©sitez pas √† utiliser les √©v√©nements √† votre avantage, ils peuvent renverser la partie !",
    "Un vote blanc ou une √©galit√© peut sauver un Undercover en difficult√©. Discutez bien avant de voter !",
    "Si vous √™tes l'Undercover et que vous avez une id√©e du mot des Civils, essayez de donner un indice qui correspond aux deux mots.",
    "En mode R√©volution, pr√©parez-vous √† tout ! Les r√¥les peuvent changer √† tout moment.",
    "N'ayez pas peur de voter contre quelqu'un qui semble s√ªr de lui, c'est peut-√™tre une tactique !"
  ];
  const THEME_ICONS = { "Culture Pop": "üçø", "Vie Quotidienne": "üè†", "Gastronomie": "üçî", "Culture G & Arts": "üé®", "Lieux & Voyages": "‚úàÔ∏è", "Animaux & Nature": "üêæ", "Science & Tech": "üî¨", "Sport": "‚öΩ", "Culture Alg√©rienne": "üá©üáø", "Mots Pi√©g√©s & Absurdes": "ü§™", "Histoire & Mythologie": "üìú", "Marques C√©l√®bres": "¬ÆÔ∏è", "Corps Humain": "üß¨", "random": "üé≤" };

  // ---------- DOM & STATE ----------
  const dom = {};
  let setupAgentNames = [];
  const state = {
    players: [], wordPair: null,
    settings: { 
        gameMode: 'dynamic', // classic, dynamic, revolution
        theme: 'Culture Pop', 
        playerCount: 4, botCount: 0, 
        undercoverCount: 1, 
        sound:false, innocent:false, jester: false, agentBlanc: false
    },
    round: 1, distributionIndex: 0,
    lastEliminated: null, lastVotes: {}, lastSuspect: null,
    tabooWord: null,
    maxPlayers: 12, minPlayers: 3,
    setupStep: 1, isNavigating: false,
    _activeScreen: 'home', _gameController: null, _currentEvent: null
  };

  const getDOMElements = () => {
    const ids = [
      'screen-home', 'screen-setup', 'screen-pass', 'screen-game', 'screen-reveal', 'screen-end', 'screen-lastword', 'screen-event',
      'theme-grid', 'minus', 'plus', 'playerNum', 'minusBot', 'plusBot', 'botNum', 'playersSetup',
      'btnReset', 'btnHelp', 'btnNewWord', 'btnShowMyCard', 'option-sound', 'option-innocent', 'option-jester', 'option-agent-blanc',
      'mode-classic', 'mode-dynamic', 'mode-revolution', 'mode-fast',
      'currentName', 'revealCard', 'secretWord', 'start-game-btn', 'tips-btn', 'game-header',
      'turn-display', 'game-content-area', 'lastword-prompt', 'lastword-grid',
      'event-icon', 'event-title', 'event-description',
      'revealPhoto', 'revealTitle', 'roleBadge', 'revealedWord', 'winnerBanner', 'summary', 'actionBar',
      'vote-reveal-container', 'vote-reveal-details',
      'modal-template', 'modal-title', 'modal-message', 'modal-input-wrap', 'modal-input', 'modal-actions'
    ];
    ids.forEach(id => dom[id.replace(/-(\w)/g, (m, g) => g.toUpperCase())] = document.getElementById(id));
    dom.screens = {
        home: dom.screenHome, setup: dom.screenSetup, pass: dom.screenPass, game: dom.screenGame,
        reveal: dom.screenReveal, end: dom.screenEnd, lastword: dom.screenLastword, event: dom.screenEvent
    };
  };

  // ---------- UTILS ----------
  const rand = (n)=> Math.floor(Math.random()*n);
  const shuffle = (arr)=> arr.map(v=>[Math.random(),v]).sort((a,b)=>a[0]-b[0]).map(x=>x[1]);
  const byId = (id)=> state.players.find(p=>p.id===id);
  const alive = ()=> state.players.filter(p=>p.alive);
  const clamp = (n,min,max)=> Math.max(min, Math.min(max, n));
  
  function show(screenId, direction = 'forward'){
    const currentScreen = dom.screens[state._activeScreen];
    const nextScreen = dom.screens[screenId];

    if (!nextScreen || (currentScreen && currentScreen === nextScreen) || state.isNavigating) return;
    state.isNavigating = true;

    const outClass = direction === 'forward' ? 'slide-out-left' : 'slide-out-right';
    const inClass = direction === 'forward' ? 'slide-in-right' : 'slide-in-left';

    const animationPromises = [];

    if (currentScreen) {
        currentScreen.classList.add(outClass);
        animationPromises.push(new Promise(resolve => {
            currentScreen.addEventListener('animationend', function handler(e) {
                if (e.target === currentScreen) {
                    currentScreen.classList.remove('active', outClass);
                    currentScreen.removeEventListener('animationend', handler);
                    resolve();
                }
            }, { once: true });
        }));
    }

    nextScreen.classList.add('active');
    nextScreen.classList.add(inClass);
    animationPromises.push(new Promise(resolve => {
        nextScreen.addEventListener('animationend', function handler(e) {
            if (e.target === nextScreen) {
                nextScreen.classList.remove(inClass);
                nextScreen.removeEventListener('animationend', handler);
                resolve();
            }
        }, { once: true });
    }));

    Promise.all(animationPromises).then(() => {
        state.isNavigating = false;
    });

    state._activeScreen = screenId;
    dom.gameHeader.style.display = ['home', 'setup'].includes(screenId) ? 'none' : 'block';
    updateActionBar(screenId);
    const inGame = ['pass', 'game', 'reveal', 'lastword', 'event'].includes(screenId);
    dom.btnNewWord.style.display = inGame ? 'inline-flex' : 'none';
    dom.btnShowMyCard.style.display = inGame ? 'inline-flex' : 'none';
  }
  window.show = show; // Expose for testing

  // ---------- MODAL SYSTEM ----------
  const showModal = (config) => {
    dom.modalTitle.textContent = config.title;
    dom.modalMessage.innerHTML = config.message;
    dom.modalInputWrap.style.display = config.input ? 'block' : 'none';
    if (config.input) {
        dom.modalInput.placeholder = config.input.placeholder || '';
        dom.modalInput.value = '';
        setTimeout(() => dom.modalInput.focus(), 100);
    }
    dom.modalActions.innerHTML = '';
    if (config.buttons && config.buttons.length > 0) {
        config.buttons.forEach((btnConfig, i) => {
            const button = document.createElement('button');
            button.className = `btn ${btnConfig.class || ''}`;
            button.textContent = btnConfig.text;
            button.style.flex = 1;
            button.style.animation = `fadeInUp .4s ${150 + i * 60}ms both`;
            button.onclick = () => {
                const inputValue = config.input ? dom.modalInput.value : null;
                if (btnConfig.onClick) btnConfig.onClick(inputValue);
                if (!config.preventClose) dom.modalTemplate.close();
            };
            dom.modalActions.appendChild(button);
        });
    }
    if (dom.modalTemplate.open) dom.modalTemplate.close();
    dom.modalTemplate.showModal();
  };

  // ---------- AUDIO & HAPTICS ----------
  let audioCtx = null;
  function initAudio(){ if(!audioCtx){ const Ctx = window.AudioContext || window.webkitAudioContext; if(Ctx){ audioCtx = new Ctx(); } } if(audioCtx && audioCtx.state==='suspended'){ audioCtx.resume(); } }
  function beep(type='sine', freq=880, dur=0.1, vol=0.1){
    if(!state.settings.sound || !audioCtx) return;
    const t0 = audioCtx.currentTime;
    const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
    o.type=type; o.frequency.setValueAtTime(freq, t0);
    g.gain.setValueAtTime(0.0001, t0); g.gain.exponentialRampToValueAtTime(vol, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(t0); o.stop(t0 + dur);
  }
  function haptic(type = 'light') {
    if (navigator.vibrate) {
        navigator.vibrate(type === 'heavy' ? [50] : [20]);
    }
  }
  const sounds = {
    click: ()=> { beep('sine', 1200, 0.06); },
    flip: ()=> { beep('sine', 900, 0.08); haptic('light'); },
    start: ()=> { beep('sine', 740, 0.1); haptic('heavy'); },
    eliminate: ()=> { beep('sawtooth', 420, 0.15, 0.08); haptic('heavy'); },
    win: ()=> { beep('sine', 740, 0.1); setTimeout(()=>beep('sine', 880, 0.1),120); setTimeout(()=>beep('sine', 1046, 0.1),250); },
    lose: ()=> { beep('sine', 440, 0.1); setTimeout(()=>beep('sine', 330, 0.1),120); },
    tick: (fast=false)=> { if (!fast) beep('sine', 1000, 0.05, 0.05); },
    event: ()=> { beep('sawtooth', 1500, 0.05); setTimeout(()=>beep('sawtooth', 1800, 0.1), 80); }
  };

  // ---------- IMAGE & AVATAR ----------
  function fileToDataURL(file, maxW=520, maxH=520){
    return new Promise((resolve,reject)=>{
      const fr = new FileReader();
      fr.onload=()=>{ const img=new Image(); img.onload=()=>{ const r=Math.min(maxW/img.width,maxH/img.height,1),w=Math.round(img.width*r),h=Math.round(img.height*r); const c=document.createElement('canvas');c.width=w;c.height=h; c.getContext('2d').drawImage(img,0,0,w,h); resolve(c.toDataURL('image/jpeg',.9)); }; img.onerror=reject; img.src=fr.result; }; fr.onerror=reject; fr.readAsDataURL(file);
    });
  }
  function avatarHTML(p){
    if(p?.photo) return `<div class="avatar"><img src="${p.photo}" alt="photo ${p.name||'joueur'}"></div>`;
    const init = (p?.name||'Joueur').split(' ').map(x=>x[0]).slice(0,2).join('').toUpperCase();
    return `<div class="avatar">${init||'J'}</div>`;
  }

  // ---------- SETUP ----------
  function showSetupStep(step, direction = 'forward') {
    const fromStep = state.setupStep;
    const toStep = clamp(step, 1, 5);
    if (fromStep === toStep || state.isNavigating) return;

    state.isNavigating = true;

    const currentStepEl = document.querySelector(`.setup-step[data-step="${fromStep}"]`);
    const nextStepEl = document.querySelector(`.setup-step[data-step="${toStep}"]`);

    if (!nextStepEl) {
        state.isNavigating = false;
        return;
    }

    const outClass = direction === 'forward' ? 'slide-out-left' : 'slide-out-right';
    const inClass = direction === 'forward' ? 'slide-in-right' : 'slide-in-left';

    const animationPromises = [];

    if (currentStepEl) {
        currentStepEl.classList.add(outClass);
        animationPromises.push(new Promise(resolve => {
            currentStepEl.addEventListener('animationend', function handler(e) {
                if (e.target === currentStepEl) {
                    currentStepEl.classList.remove('active', outClass);
                    currentStepEl.removeEventListener('animationend', handler);
                    resolve();
                }
            }, { once: true });
        }));
    }

    nextStepEl.classList.add('active', inClass);
    animationPromises.push(new Promise(resolve => {
        nextStepEl.addEventListener('animationend', function handler(e) {
            if (e.target === nextStepEl) {
                nextStepEl.classList.remove(inClass);
                nextStepEl.removeEventListener('animationend', handler);
                resolve();
            }
        }, { once: true });
    }));

    Promise.all(animationPromises).then(() => {
        state.isNavigating = false;
    });
    state.setupStep = toStep;
    updateActionBar('setup');
  }

  function renderPlayerSetup(){
    dom.playersSetup.innerHTML='';
    const n = state.settings.playerCount;
    for (let i=0;i<n;i++){
      const p = state.players[i] || {id:i+1, name:'', photo:null};
      const row = document.createElement('div');
      row.className='player-row';
      row.style.animation = `fadeInUp .5s ${i * 50}ms both`;
      row.innerHTML = `
        ${avatarHTML(p)}
        <input type="text" placeholder="Nom de l'agent..." value="${p.name||''}" data-idx="${i}" style="flex:1">
        <div class="camera-row" style="display:flex; gap: 0.25rem;">
          <button class="icon-btn" data-random="${i}" title="Nom al√©atoire"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 3h5v5"/><path d="M4 20L21 3"/><path d="M21 16v5h-5"/><path d="M15 15l6 6"/><path d="M4 4l5 5"/></svg></button>
          <button class="icon-btn" data-idx="${i}" title="Prendre/importer une photo"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/></svg></button>
          <button class="icon-btn" data-remove="${i}" title="Supprimer la photo" style="${p.photo ? '' : 'display:none;'}"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg></button>
          <input type="file" accept="image/*" data-file="${i}" class="sr-only">
        </div>`;
      dom.playersSetup.appendChild(row);
    }
    dom.playersSetup.querySelectorAll('input[type="text"]').forEach(inp=>inp.oninput=(e)=>{ const i=parseInt(e.target.dataset.idx,10); state.players[i]=state.players[i]||{id:i+1}; state.players[i].name=e.target.value; });
    dom.playersSetup.querySelectorAll('button[data-random]').forEach(btn=>btn.onclick=()=>{ const i=parseInt(btn.dataset.random,10); if(setupAgentNames.length === 0) setupAgentNames = shuffle([...RANDOM_AGENT_NAMES]); const newName = setupAgentNames.pop(); if(state.players[i]) { state.players[i].name = newName; } else { state.players[i] = {id:i+1, name: newName, photo: null}; } renderPlayerSetup(); });
    dom.playersSetup.querySelectorAll('button[data-idx]').forEach(btn=>btn.onclick=()=>{ const i=parseInt(btn.dataset.idx,10); dom.playersSetup.querySelector(`input[data-file="${i}"]`)?.click(); });
    dom.playersSetup.querySelectorAll('button[data-remove]').forEach(btn=>btn.onclick=()=>{ const i=parseInt(btn.dataset.remove,10); if(state.players[i])state.players[i].photo=null; renderPlayerSetup(); });
    dom.playersSetup.querySelectorAll('input[data-file]').forEach(inp=>inp.onchange=async(e)=>{ const i=parseInt(e.target.dataset.file,10); const file=e.target.files?.[0]; if(!file)return; try{const d=await fileToDataURL(file);(state.players[i]||={id:i+1}).photo=d;renderPlayerSetup();}catch{showModal({title:"Erreur",message:"Impossible de charger la photo.",buttons:[{text:"OK"}]})}});
  }

  function renderThemeSelection() {
      dom.themeGrid.innerHTML = '';
      const themes = [['Al√©atoire', 'random'], ...Object.keys(THEME_DATA).map(t => [t,t])];

      themes.forEach(([name, value], i) => {
          const card = document.createElement('div');
          card.className = 'theme-card';
          card.dataset.theme = value;
          if (state.settings.theme === value) card.classList.add('active');
          card.innerHTML = `<div class="icon">${THEME_ICONS[value] || '‚ú®'}</div><div class="label">${name}</div>`;
          card.style.animation = `fadeInUp .4s ${i * 30}ms both`;
          card.onclick = () => {
              state.settings.theme = value;
              sounds.click();
              dom.themeGrid.querySelectorAll('.theme-card').forEach(c => c.classList.remove('active'));
              card.classList.add('active');
          };
          dom.themeGrid.appendChild(card);
      });
  }

  function initSetup(){
    state.setupStep = 1;
    document.querySelectorAll('.setup-step').forEach(el => {
        el.classList.toggle('active', el.dataset.step === '1');
    });

    setupAgentNames = shuffle([...RANDOM_AGENT_NAMES]);
    
    renderThemeSelection();

    // Load saved players
    const savedPlayers = JSON.parse(localStorage.getItem('undercoverPlayers') || '[]');
    state.settings.playerCount = savedPlayers.length > 0 ? savedPlayers.length : 4;
    state.players = savedPlayers.length > 0 ? savedPlayers : Array.from({length:4}, (_,i)=>({id:i+1, name:'', photo:null}));

    dom.playerNum.textContent = state.settings.playerCount;
    dom.botNum.textContent = state.settings.botCount;
    renderPlayerSetup();
    
    const updateOptionCards = () => {
        ['sound', 'innocent', 'jester', 'agentBlanc'].forEach(key => {
            // Correctly constructs dom property name like 'optionInnocent' or 'optionAgentBlanc'
            const domKey = `option${key.charAt(0).toUpperCase() + key.slice(1)}`;
            const el = dom[domKey];
            if (!el) return;
            el.classList.toggle('active', state.settings[key]);
            el.querySelector('.value').textContent = state.settings[key] ? 'Activ√©' : 'D√©sactiv√©';
        });
        ['classic', 'dynamic', 'revolution', 'fast'].forEach(mode => {
            if(dom[`mode${mode.charAt(0).toUpperCase() + mode.slice(1)}`]) dom[`mode${mode.charAt(0).toUpperCase() + mode.slice(1)}`].classList.toggle('active', state.settings.gameMode === mode);
        });
    };
    updateOptionCards();

    const updateTotalPlayerCount = () => {
        const total = state.settings.playerCount + state.settings.botCount;
        if (total > state.maxPlayers) {
            state.settings.playerCount = state.maxPlayers - state.settings.botCount;
        }
        dom.playerNum.textContent = state.settings.playerCount;
        dom.botNum.textContent = state.settings.botCount;
        
        const currentCount = state.players.length;
        if (state.settings.playerCount > currentCount) {
            for(let i = currentCount; i < state.settings.playerCount; i++) {
                state.players.push({id: i + 1, name: '', photo: null});
            }
        } else if (state.settings.playerCount < currentCount) {
            state.players.splice(state.settings.playerCount);
        }
        renderPlayerSetup();
    };

    dom.minus.onclick = ()=>{ state.settings.playerCount = clamp(state.settings.playerCount - 1, 0, state.maxPlayers); updateTotalPlayerCount(); };
    dom.plus.onclick  = ()=>{ state.settings.playerCount = clamp(state.settings.playerCount + 1, 0, state.maxPlayers); updateTotalPlayerCount(); };
    dom.minusBot.onclick = ()=>{ state.settings.botCount = clamp(state.settings.botCount - 1, 0, state.maxPlayers); updateTotalPlayerCount(); };
    dom.plusBot.onclick  = ()=>{ state.settings.botCount = clamp(state.settings.botCount + 1, 0, state.maxPlayers); updateTotalPlayerCount(); };

    ['sound', 'innocent', 'jester', 'agentBlanc'].forEach(key => {
        const domKey = `option${key.charAt(0).toUpperCase() + key.slice(1)}`;
        const el = dom[domKey];
        if (!el) return;
        el.onclick = () => {
            state.settings[key] = !state.settings[key];
            if(key==='sound' && state.settings.sound) { initAudio(); sounds.click(); }
            updateOptionCards();
        };
    });
    ['classic', 'dynamic', 'revolution', 'fast'].forEach(mode => {
        const modeEl = dom[`mode${mode.charAt(0).toUpperCase() + mode.slice(1)}`];
        if (modeEl) {
            modeEl.onclick = () => {
                state.settings.gameMode = mode;
                updateOptionCards();
            };
        }
    });
  }

  // ---------- GAME FLOW ----------
  function startGame(isNewWord = false){
    const { playerCount, botCount, undercoverCount, innocent, jester, agentBlanc } = state.settings;
    const n = playerCount + botCount;
    if (n < state.minPlayers) { showModal({title:"Pas assez de joueurs", message:`Il faut au moins ${state.minPlayers} agents au total (humains + bots).`, buttons:[{text:"OK"}]}); return; }
    
    const U = (n < 4) ? 1 : undercoverCount;
    const I = (n < 3) ? 0 : (innocent ? 1 : 0);
    const J = (n < 4) ? 0 : (jester ? 1 : 0);
    const AB = (n < 4) ? 0 : (agentBlanc ? 1 : 0);
    const civils = n - U - I - J - AB;

    if (civils < 1){ showModal({title:"Configuration invalide", message:"Configuration de r√¥les impossible. Essayez avec plus de joueurs ou moins de r√¥les sp√©ciaux.", buttons:[{text:"OK"}]}); return; }
    
    sounds.start();
    state.round = 1; state.distributionIndex = 0; state.lastSuspect = null; state._currentEvent = null;

    let themeKey = state.settings.theme;
    if (themeKey === 'random') {
        const themeKeys = Object.keys(THEME_DATA);
        themeKey = themeKeys[rand(themeKeys.length)];
    }
    let list = THEME_DATA[themeKey];
    state.wordPair = list[rand(list.length)];

    const oldPlayers = isNewWord ? state.players.filter(p => !p.isBot) : [];
    const humanPlayersToSave = [];
    state.players = [];
    const botNames = shuffle(["Alpha", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot", "Golf", "Hotel", "India", "Juliett", "Kilo", "Lima"]);
    if (setupAgentNames.length < playerCount) setupAgentNames = shuffle([...RANDOM_AGENT_NAMES]);
    
    for(let i=0; i<playerCount; i++) {
        const existingPlayer = isNewWord && oldPlayers[i] ? oldPlayers[i] : (state.players[i] || {});
        const name = (document.querySelector(`#playersSetup input[data-idx="${i}"]`)?.value || '').trim() || existingPlayer.name || setupAgentNames.pop() || `Agent ${i+1}`;
        const photo = existingPlayer?.photo || null;
        state.players.push({ id: i+1, name, photo, isBot: false, alive: true });
        humanPlayersToSave.push({id: i+1, name, photo});
    }
    localStorage.setItem('undercoverPlayers', JSON.stringify(humanPlayersToSave));

    for(let i=0; i<botCount; i++) {
        state.players.push({ id: playerCount + i + 1, name: `Bot ${botNames[i]}`, photo: null, isBot: true, alive: true });
    }

    const p_ids = shuffle(state.players.map(p=>p.id));
    let assigned_roles = 0;
    for(let i=0; i<U; i++){ const p = byId(p_ids[i]); p.role='undercover'; p.word=state.wordPair.b; assigned_roles++; }
    if(I === 1 && p_ids.length > assigned_roles){ const p = byId(p_ids[assigned_roles]); p.role='innocent'; p.word = "???"; assigned_roles++; }
    if(J === 1 && p_ids.length > assigned_roles){ const p = byId(p_ids[assigned_roles]); p.role='jester'; p.word = "???"; assigned_roles++; }
    if(AB === 1 && p_ids.length > assigned_roles){ const p = byId(p_ids[assigned_roles]); p.role='agentBlanc'; p.word = "???"; assigned_roles++; }
    state.players.forEach(p => {
        if (!p.role) { p.role = 'civil'; p.word = state.wordPair.a; }
    });

    state._gameController = new GameController();
    
    if (playerCount > 0) {
        show('pass');
        renderRevealCard();
    } else { 
        state._gameController.startRound();
    }
  }

  function renderRevealCard(){
    dom.revealCard.classList.remove('flipped');
    const player = state.players.filter(p => !p.isBot)[state.distributionIndex];
    if (!player) return;
    dom.currentName.textContent = player.name;
    if (player.role === 'innocent') {
        dom.secretWord.textContent = "Vous √™tes l'Innocent";
    } else if (player.role === 'jester') {
        dom.secretWord.textContent = "Vous √™tes le Jester";
    } else if (player.role === 'agentBlanc') {
        dom.secretWord.textContent = "Vous √™tes l'Agent Blanc";
    } else {
        dom.secretWord.textContent = player.word || "‚Äî";
    }
  }
  
  function nextPlayerReveal() {
      if (dom.revealCard.classList.contains('flipped')) {
          showModal({title: "Cachez votre mot !", message: "Retournez la carte avant de passer au joueur suivant.", buttons:[{text:"OK"}]});
          return;
      }
      sounds.click();
      
      const humanPlayers = state.players.filter(p => !p.isBot);
      const isLastPlayer = state.distributionIndex >= humanPlayers.length - 1;

      dom.revealCard.style.transition = 'transform .3s ease-in, opacity .3s ease-in';
      dom.revealCard.style.transform = 'translateX(150%)';
      dom.revealCard.style.opacity = '0';
      
      setTimeout(() => {
          if (isLastPlayer) {
              showModal({ title: "Mission activ√©e !", message: "Tous les agents ont re√ßu leurs instructions. La phase de jeu commence.", buttons: [] });
              setTimeout(() => {
                  if (dom.modalTemplate.open) dom.modalTemplate.close();
                  state._gameController.startRound();
              }, 2000);
          } else {
              state.distributionIndex++;
              renderRevealCard();
              dom.revealCard.style.transition = 'none'; 
              dom.revealCard.style.transform = 'translateX(-150%)';
              void dom.revealCard.offsetWidth;
              dom.revealCard.style.transition = 'transform .3s ease-out, opacity .3s ease-out';
              dom.revealCard.style.transform = 'translateX(0)';
              dom.revealCard.style.opacity = '1';
              setTimeout(() => {
                  dom.revealCard.style.transition = '';
                  dom.revealCard.style.transform = '';
                  dom.revealCard.style.opacity = '';
              }, 300);
          }
      }, 300);
  }
  
  function eliminate(player){
    sounds.eliminate();
    player.alive = false; 
    state.lastEliminated = player;
    dom.revealTitle.textContent = `${player.name} est √©limin√©¬∑e`;
    dom.revealPhoto.innerHTML = avatarHTML(player);
    let roleText = 'R√¥le : Civil';
    if(player.role === 'undercover') roleText = 'R√¥le : Undercover';
    if(player.role === 'innocent') roleText = 'R√¥le : Innocent';
    if(player.role === 'jester') roleText = 'R√¥le : Jester';
    if(player.role === 'agentBlanc') roleText = 'R√¥le : Agent Blanc';
    dom.roleBadge.textContent = roleText;
    dom.revealedWord.innerHTML = player.word && player.role !== 'innocent' ? `Mot : <b>${player.word}</b>` : 'Ce joueur n\'avait pas de mot.';
    
    show('reveal');
  }

  function handlePostElimination() {
    const player = state.lastEliminated;
    if (player.role === 'jester') {
        endGame('jester');
        return;
    }
    if (player.role === 'innocent') {
        showModal({
            title: "L'Innocent a √©t√© d√©couvert !", message: "Pour gagner, vous devez deviner le mot des <b>Civils</b>.",
            input: { placeholder: "Quel √©tait le mot des Civils ?" },
            buttons: [{ text: "Valider", class: "warn", onClick: (guess) => {
                if(guess && guess.trim().toLowerCase() === state.wordPair.a.toLowerCase()) { endGame('innocent'); } 
                else { showModal({title:"Mauvaise r√©ponse !", message:`Le mot des civils √©tait "<b>${state.wordPair.a}</b>". La partie continue.`, buttons:[{text:"OK", onClick: checkVictory }]}); }
            }}]
        });
    } else {
        showLastWordScreen();
    }
  }

  function showLastWordScreen() {
    const player = state.lastEliminated;
    dom.lastwordPrompt.innerHTML = `<b>${player.name}</b>, avant de partir, d√©signez un joueur que vous trouvez suspect.`;
    const grid = dom.lastwordGrid;
    grid.innerHTML = '';
    alive().forEach((p, i) => {
        const card = document.createElement('div');
        card.className = 'player-vote-card';
        card.style.animation = `fadeInUp .4s ${i * 50}ms both`;
        card.innerHTML = `${avatarHTML(p)}<div class="name">${p.name}</div>`;
        card.onclick = () => {
            state.lastSuspect = p.id;
            sounds.click();
            checkVictory();
        };
        grid.appendChild(card);
    });
    show('lastword');
  }

  function checkVictory(){
    if (state._activeScreen === 'end') return;
    
    const u_alive = alive().filter(p => p.role === 'undercover');
    const ab_alive = alive().filter(p => p.role === 'agentBlanc');
    const non_undercovers_alive = alive().filter(p => p.role !== 'undercover');

    // Undercover win condition
    if(u_alive.length >= non_undercovers_alive.length){
        endGame('undercover');
        return;
    }

    // Civil / Agent Blanc win condition
    if(u_alive.length === 0) {
        // Undercovers are gone. Now it's between Civils and Agent Blanc (if present).
        if (ab_alive.length > 0) {
            const agent = ab_alive[0];
            showModal({
                title: `L'Agent Blanc a Surv√©cu !`,
                message: `<b>${agent.name}</b>, tous les Undercover ont √©t√© √©limin√©s. Pour remporter la victoire, vous devez maintenant deviner le mot des Civils !`,
                input: { placeholder: "Le mot des Civils..." },
                preventClose: true,
                buttons: [{ text: "Valider", class: "warn", onClick: (guess) => {
                    if(guess && guess.trim().toLowerCase() === state.wordPair.a.toLowerCase()) {
                        endGame('agentBlanc');
                    } else {
                        showModal({title:"Mauvaise r√©ponse !", message:`Le mot des Civils √©tait "<b>${state.wordPair.a}</b>". Les Civils remportent la partie !`, buttons:[{text:"OK", onClick: () => endGame('civils') }]});
                    }
                }}]
            });
        } else {
            // No Agent Blanc, Civils win normally.
            endGame('civils');
        }
        return;
    }
    
    // If no one has won, continue the game
    if (['reveal', 'lastword'].includes(state._activeScreen)) {
        actions.reveal[0].action();
    }
  }

  function endGame(winner){
    let banner = '', detail='';
    if(winner==='civils'){ banner='Victoire des Civils !'; detail='Les Undercover ont √©t√© d√©masqu√©s.'; sounds.win(); }
    else if(winner==='innocent'){ banner='Victoire de l\'Innocent !'; detail='Il a devin√© le mot des civils !'; sounds.win(); }
    else if(winner==='jester'){ banner='Victoire du Jester !'; detail='Le Jester a r√©ussi √† se faire √©liminer !'; sounds.win(); }
    else if(winner==='agentBlanc'){ banner='Victoire de l\'Agent Blanc !'; detail='L\'Agent Blanc a d√©masqu√© les Civils !'; sounds.win(); }
    else { banner='Victoire des Undercover !'; detail='Ils ont atteint la parit√© ou sont les derniers en lice.'; sounds.lose(); }
    
    dom.winnerBanner.innerHTML = banner;
    const civils = state.players.filter(p=>p.role==='civil').map(p=>p.name).join(', ');
    const undercovers = state.players.filter(p=>p.role==='undercover').map(p=>p.name).join(', ');
    const innocent = state.players.find(p=>p.role==='innocent');
    const jester = state.players.find(p=>p.role==='jester');
    const agentBlanc = state.players.find(p=>p.role==='agentBlanc');
    
    let summaryHtml = `${detail}<br><br><b>Civils (${state.wordPair.a})</b>: ${civils || 'aucun'}<br><b>Undercover (${state.wordPair.b})</b>: ${undercovers || 'aucun'}`;
    if (innocent) summaryHtml += `<br><b>Innocent</b>: ${innocent.name}`;
    if (jester) summaryHtml += `<br><b>Jester</b>: ${jester.name}`;
    if (agentBlanc) summaryHtml += `<br><b>Agent Blanc</b>: ${agentBlanc.name}`;

    dom.summary.innerHTML = summaryHtml;
    
    if (Object.keys(state.lastVotes).length > 0) {
        dom.voteRevealContainer.style.display = 'block';
        dom.voteRevealDetails.innerHTML = '';
        Object.keys(state.lastVotes).forEach((voterId, i) => {
            const voter = byId(parseInt(voterId));
            const target = byId(state.lastVotes[voterId]);
            if(voter && target) {
                const isSuspect = state.lastSuspect === parseInt(voterId);
                const gridItem = document.createElement('div');
                gridItem.className = 'vote-reveal-grid';
                gridItem.style.animation = `fadeInUp .4s ${i * 75}ms both`;
                gridItem.innerHTML = `
                        <div class="vote-reveal-item"><div class="avatar">${avatarHTML(voter)}</div><div class="name">${voter.name}</div></div>
                        <div class="vote-arrow ${isSuspect ? 'suspect' : ''}">‚Üí</div>
                        <div class="vote-reveal-item"><div class="avatar">${avatarHTML(target)}</div><div class="name">${target.name}</div></div>
                    `;
                dom.voteRevealDetails.appendChild(gridItem);
            }
        });
    } else {
        dom.voteRevealContainer.style.display = 'none';
    }

    show('end');
  }
  
  // ---------- ACTION BAR & NAVIGATION ----------
  const actions = {
    pass: [{ text: 'Agent suivant ‚Üí', action: nextPlayerReveal }],
    event: [{ text: 'Compris !', action: () => state._gameController.continueFromEvent() }],
    reveal: [{ text: 'Continuer', action: () => { 
        if(state._activeScreen === 'reveal') {
            handlePostElimination();
        } else {
            if(state._activeScreen !== 'end') { 
                state.round++; 
                if(state._gameController) state._gameController.startRound(); 
            }
        }
    }}],
    end: [{ text: 'Menu principal', class: 'ghost', flex: 1, action: () => { initSetup(); show('home', 'backward'); } }, { text: 'Rejouer', class: '', flex: 2, action: () => { state.players.forEach(p=>{ p.alive=true; }); startGame(true); }}]
  };

  function updateActionBar(screenId) {
      const bar = dom.actionBar;
      bar.innerHTML = '';
      
      if (screenId === 'setup') {
          bar.classList.add('visible');
          let i = 0;
          if (state.setupStep > 1) {
              const backBtn = document.createElement('button');
              backBtn.className = 'btn ghost';
              backBtn.textContent = '‚Üê Pr√©c√©dent';
              backBtn.onclick = () => showSetupStep(state.setupStep - 1, 'backward');
              backBtn.style.animation = `fadeInUp .4s ${i * 60}ms both`;
              i++;
              bar.appendChild(backBtn);
          }
          const nextBtn = document.createElement('button');
          nextBtn.className = 'btn';
          if (state.setupStep < 5) {
              nextBtn.textContent = 'Suivant ‚Üí';
              nextBtn.onclick = () => showSetupStep(state.setupStep + 1, 'forward');
          } else {
              nextBtn.textContent = 'Lancer la mission';
              nextBtn.onclick = () => startGame(false);
          }
          nextBtn.style.animation = `fadeInUp .4s ${i * 60}ms both`;
          bar.appendChild(nextBtn);
          return;
      }

      const screenActions = actions[screenId];
      if (screenActions) {
          screenActions.forEach((config, i) => {
              const button = document.createElement('button');
              button.className = `btn ${config.class || ''}`;
              button.textContent = config.text;
              if (config.flex) button.style.flex = config.flex;
              button.onclick = config.action;
              button.style.animation = `fadeInUp .4s ${i * 60}ms both`;
              bar.appendChild(button);
          });
          bar.classList.add('visible');
      } else { bar.classList.remove('visible'); }
  }
  
  // ---------- RANDOM EVENTS ----------
  const randomEvents = [
    {
      id: 'doubleVote', title: 'Vote Double', icon: 'üó≥Ô∏èüó≥Ô∏è',
      description: (p) => `<b>${p.name}</b>, votre vote comptera double lors de la prochaine √©limination !`,
      effect: (p) => { p.doubleVote = true; }
    },
    {
      id: 'silence', title: 'Silence Radio', icon: 'ü§´',
      description: (p) => `<b>${p.name}</b>, vous n'avez pas le droit de parler jusqu'au prochain tour. Donnez votre indice en mimant !`,
      effect: (p) => { p.silenced = true; }
    },
    {
      id: 'oracle', title: 'L\'Oracle', icon: 'üîÆ',
      description: (p1, p2) => `<b>${p1.name}</b>, vous avez une vision ! Vous savez maintenant que <b>${p2.name}</b> est <b>${p2.role}</b>.`,
      effect: (p1, p2) => { /* Purely informational for p1 */ }
    },
    {
      id: 'amnesia', title: 'Amn√©sie', icon: 'üòµ',
      description: (p) => `<b>${p.name}</b>, vous oubliez votre mot pour ce tour ! Vous devrez le deviner gr√¢ce aux autres.`,
      effect: (p) => { p.amnesia = true; }
    },
    {
      id: 'paranoia', title: 'Parano√Øa', icon: 'üëÄ',
      description: () => `Attention ! Tous les votes de ce tour seront r√©v√©l√©s publiquement √† la fin !`,
      effect: () => { state.paranoia = true; }
    },
    {
      id: 'revolution', title: 'R√©volution !', icon: 'üí•',
      description: () => `REVOLUTION ! Tous les Civils deviennent Undercover, et vice-versa ! Vos mots sont √©chang√©s !`,
      effect: () => {
        state.players.forEach(p => {
          if (p.role === 'civil') { p.role = 'undercover'; p.word = state.wordPair.b; }
          else if (p.role === 'undercover') { p.role = 'civil'; p.word = state.wordPair.a; }
        });
      },
      modes: ['revolution']
    },
    {
      id: 'interrogation', title: 'Interrogatoire', icon: 'üîç',
      description: (p1, p2) => `<b>${p1.name}</b> a men√© un interrogatoire secret sur <b>${p2.name}</b>... L'information est cruciale.`,
      effect: (p1, p2) => {
        if (!p1.isBot) {
          const wordToShow = p2.role === 'innocent' || p2.role === 'jester' || p2.role === 'agentBlanc'
            ? "Cet agent n'a pas de mot."
            : p2.word;
          setTimeout(() => showModal({
            title: "Rapport d'Interrogatoire",
            message: `Le mot de <b>${p2.name}</b> est : <div class="word-big" style="margin-top:0.5rem;">${wordToShow}</div>`,
            buttons: [{text: "Compris"}]
          }), 500);
        }
      }
    },
    {
      id: 'motTabou', title: 'Mot Tabou', icon: 'üö´',
      description: (word) => `Le mot "<b>${word}</b>" est TABOU ce tour. L'utiliser comme indice annulera votre vote !`,
      effect: (word) => {
        state.tabooWord = word.toLowerCase();
      }
    }
  ];

  function triggerRandomEvent() {
    const mode = state.settings.gameMode;
    if (mode === 'classic' || Math.random() > (mode === 'revolution' ? 0.7 : 0.4)) {
        state._gameController.continueFromEvent();
        return;
    }

    const availableEvents = randomEvents.filter(e => (!e.modes || e.modes.includes(mode)) && (e.id !== 'interrogation' || alive().length >= 2));
    if (availableEvents.length === 0) {
        state._gameController.continueFromEvent();
        return;
    }

    const event = availableEvents[rand(availableEvents.length)];
    state._currentEvent = event;
    const players = shuffle(alive());
    
    dom.eventIcon.textContent = event.icon;
    dom.eventTitle.textContent = event.title;
    
    // Single-player events
    const singlePlayerEvents = ['doubleVote', 'silence', 'amnesia'];
    // Two-player events
    const twoPlayerEvents = ['oracle', 'interrogation'];

    if (singlePlayerEvents.includes(event.id)) {
        const p1 = players[0];
        event.effect(p1);
        dom.eventDescription.innerHTML = event.description(p1);
    } else if (twoPlayerEvents.includes(event.id)) {
        const p1 = players[0];
        const p2 = players[1];
        event.effect(p1, p2);
        dom.eventDescription.innerHTML = event.description(p1, p2);
    } else if (event.id === 'motTabou') {
        const allHints = [...(state.wordPair.hintsA || []), ...(state.wordPair.hintsB || [])];
        const tabooWord = allHints.length > 0 ? allHints[rand(allHints.length)] : "mot";
        event.effect(tabooWord);
        dom.eventDescription.innerHTML = event.description(tabooWord);
    } else { // Global events like 'paranoia', 'revolution'
        event.effect();
        dom.eventDescription.innerHTML = event.description();
    }
    
    sounds.event();
    show('event');
  }

  // ---------- GAME CONTROLLER CLASS ----------
  class GameController {
    constructor() {
        this.turnOrder = [];
        this.turnIndex = 0;
        this.phase = 'hint';
        this.timerId = null;
        this.timeLeft = 0;
        this.votes = {};
        this.turnTimerDuration = state.settings.gameMode === 'fast' ? 10 : 20; // seconds
        this.voteTimerDuration = state.settings.gameMode === 'fast' ? 15 : 30; // seconds
    }

    cleanup() {
        if (this.timerId) clearInterval(this.timerId);
        this.timerId = null;
        dom.actionBar.innerHTML = '';
        dom.actionBar.classList.remove('visible');
    }

    startRound() {
        this.cleanup();
        state.players.forEach(p => { p.votes = 0; p.hintGiven = false; p.doubleVote = false; p.silenced = false; p.amnesia = false; p.voteDisabled = false; p.roundHints = []; });
        state.paranoia = false;
        state.tabooWord = null;
        this.votes = {};
        this.turnOrder = shuffle(alive());
        this.turnIndex = 0;
        
        triggerRandomEvent();
    }
    
    continueFromEvent() {
        this.phase = 'hint';
        show('game');
        this.nextTurn();
    }
    
    nextTurn() {
        if (this.timerId) clearInterval(this.timerId);
        
        const hintsGiven = this.turnOrder.filter(p => p.hintGiven).length;
        if (hintsGiven >= this.turnOrder.length) {
            this.startVotePhase();
            return;
        }
        
        let currentPlayer = this.turnOrder[this.turnIndex];
        while(currentPlayer.hintGiven) {
            this.turnIndex = (this.turnIndex + 1) % this.turnOrder.length;
            currentPlayer = this.turnOrder[this.turnIndex];
        }

        this.renderTurnDisplay(currentPlayer);
        dom.gameContentArea.innerHTML = `<div class="center"><p class="hint">Donnez un indice sur votre mot...</p></div>`;
        
        const mode = state.settings.gameMode;
        this.timeLeft = this.turnTimerDuration;
        this.timerId = setInterval(() => this.updateTurnTimer(currentPlayer), 1000);
        this.updateTurnTimer(currentPlayer);

        const actionBar = dom.actionBar;
        actionBar.innerHTML = '';
        
        if (currentPlayer.isBot) {
            setTimeout(() => {
                let hint = "Hmm...";
                const myHints = currentPlayer.role === 'civil' ? (state.wordPair.hintsA || []) : (state.wordPair.hintsB || []);
                const allGivenHints = state.players.flatMap(p => p.roundHints || []);

                let availableHints = myHints.filter(h => !allGivenHints.includes(h));
                if (availableHints.length === 0 && myHints.length > 0) {
                    // If all unique hints are used, just pick a random one from the original list
                    availableHints = myHints;
                }

                if (availableHints.length > 0) {
                    hint = availableHints[rand(availableHints.length)];
                } else {
                    // Fallback if no hints are defined
                    hint = currentPlayer.role === 'civil' ? "Piste" : "Indice";
                }

                this.processHint(currentPlayer, hint);
            }, rand(2000) + 1000);
        } else {
            const hintBtn = document.createElement('button');
            hintBtn.className = 'btn';
            
            if (mode === 'classic' || state.settings.botCount === 0) {
                hintBtn.textContent = "Indice Donn√© (oral)";
                hintBtn.onclick = () => this.processHint(currentPlayer, "(oral)");
            } else {
                hintBtn.textContent = "Donner l'indice";
                if (currentPlayer.silenced) hintBtn.textContent = "Mimer l'indice";
                hintBtn.onclick = () => {
                    showModal({
                        title: `Indice de ${currentPlayer.name}`, message: "Entrez votre indice (un seul mot).",
                        input: { placeholder: "Votre indice..." },
                        buttons: [
                            { text: "Annuler", class: "ghost" },
                            { text: "Valider", onClick: (hint) => { if (hint?.trim()) this.processHint(currentPlayer, hint.trim()); }}
                        ]
                    });
                };
            }
            actionBar.appendChild(hintBtn);
            actionBar.classList.add('visible');
        }
    }

    renderTurnDisplay(player) {
        dom.turnDisplay.style.display = 'flex';
        const timerHTML = `<div class="turn-player-avatar">${avatarHTML(player)}<svg class="turn-timer-ring" viewBox="0 0 36 36"><circle class="turn-timer-circle" cx="18" cy="18" r="15.9155" stroke-dasharray="100, 100" stroke-dashoffset="100"></circle></svg></div>`;
        dom.turnDisplay.innerHTML = `
            ${timerHTML}
            <div class="turn-player-name">Tour ${state.round} : Au tour de <b>${player.name}</b></div>
        `;
    }

    updateTurnTimer(player) {
        if (this.timeLeft <= 0) {
            clearInterval(this.timerId);
            this.processHint(player, "..."); // Player ran out of time
            return;
        }

        const progress = (this.timeLeft / this.turnTimerDuration) * 100;
        const circle = dom.turnDisplay.querySelector('.turn-timer-circle');
        if (circle) {
            circle.style.strokeDashoffset = 100 - progress;
            if (this.timeLeft <= 5) {
                circle.style.stroke = 'var(--danger)';
            } else {
                circle.style.stroke = 'var(--accent)';
            }
        }
        
        this.timeLeft--;
    }
    
    processHint(player, hint) {
        if (this.timerId) clearInterval(this.timerId);
        player.hintGiven = true;
        player.roundHints.push(hint);

        if (state.tabooWord && hint.toLowerCase().includes(state.tabooWord)) {
            showModal({title: "Mot Tabou !", message: `<b>${player.name}</b> a utilis√© le mot tabou ! En p√©n√©lit√©, son vote sera annul√© ce tour.`});
            player.voteDisabled = true;
        }

        dom.gameContentArea.innerHTML = `<p class="hint">${player.name} a donn√© l'indice :</p><div class="hint-text">"${hint}"</div>`;
        dom.actionBar.innerHTML = '';
        dom.actionBar.classList.remove('visible');
        
        this.turnIndex = (this.turnIndex + 1) % this.turnOrder.length;
        
        setTimeout(() => {
            this.nextTurn();
        }, 3000);
    }

    startVotePhase() {
        this.cleanup();
        this.phase = 'vote';
        show('game');
        dom.turnDisplay.style.display = 'none';
        
        this.timeLeft = this.voteTimerDuration;
        const timerDisplayHTML = `<div class="vote-timer-display">${this.timeLeft}</div>`;
        dom.gameContentArea.innerHTML = `
            <div style="text-align:center;">
                <h2>Vote Final !</h2>
                <p class="hint">Discutez et votez pour l'Undercover !</p>
                ${timerDisplayHTML}
            </div>
            <div class="player-grid-vote"></div>
        `;
        this.renderVoteGrid();
        this.timerId = setInterval(() => this.updateVoteTimer(), 1000);
        
        const actionBar = dom.actionBar;
        actionBar.innerHTML = '';
        const tallyBtn = document.createElement('button');
        tallyBtn.className = 'btn';
        tallyBtn.textContent = 'Terminer le vote';
        tallyBtn.onclick = () => this.tallyVotes();
        actionBar.appendChild(tallyBtn);
        actionBar.classList.add('visible');
    }

    updateVoteTimer() {
        if (this.timeLeft <= 0) {
            clearInterval(this.timerId);
            this.tallyVotes();
            return;
        }
        this.timeLeft--;
        const timerEl = dom.gameContentArea.querySelector('.vote-timer-display');
        if (timerEl) timerEl.textContent = this.timeLeft;
        sounds.tick(this.timeLeft <= 5);
    }
    
    renderVoteGrid() {
        const grid = dom.gameContentArea.querySelector('.player-grid-vote');
        if (!grid) return;
        grid.innerHTML = '';
        alive().forEach((player, i) => {
            const card = document.createElement('div');
            card.className = 'player-vote-card';
            card.dataset.playerId = player.id;
            card.style.animation = `fadeInUp .4s ${i * 50}ms both`;
            
            const voterIDs = Object.keys(this.votes).map(id => parseInt(id));
            const humanVoters = alive().filter(p => !p.isBot).map(p => p.id);
            const allHumansVoted = humanVoters.every(id => voterIDs.includes(id));

            if (allHumansVoted) {
                 card.classList.add('disabled');
            } else {
                 card.onclick = (e) => this.castVote(player, e.currentTarget);
            }
            
            let voteCount = 0;
            let votersList = [];
            Object.entries(this.votes).forEach(([voterId, voteData]) => {
                if (voteData.targetId === player.id) {
                    const voter = byId(parseInt(voterId));
                    if (voter) {
                        voteCount += voteData.isDouble ? 2 : 1;
                        votersList.push(voter.name + (voteData.isDouble ? ' (x2)' : ''));
                    }
                }
            });

            const voteDisplay = state.paranoia ? `<div class="votes-count" style="font-size:0.7rem; color: var(--muted);">${votersList.join(', ')}</div>` : '';
            card.innerHTML = `${avatarHTML(player)}<div class="name">${player.name}</div><div class="votes-count" style="font-weight:bold;">${'üó≥Ô∏è'.repeat(voteCount)}</div>${voteDisplay}`;
            grid.appendChild(card);
        });
    }

    castVote(target, cardElement) {
        const potentialVoters = alive().filter(p => !p.isBot && !this.votes[p.id] && !p.voteDisabled);
        if (potentialVoters.length === 0) {
            showModal({title:"Vote", message:"Tous les joueurs humains pouvant voter ont vot√©."});
            return;
        }

        let voterSelectionHTML = '';
        potentialVoters.forEach(v => {
            voterSelectionHTML += `<button class="btn ghost" data-voter-id="${v.id}" style="width:auto; flex-grow: 1;">${v.name}</button>`;
        });

        showModal({
            title: `Qui vote pour ${target.name} ?`,
            message: `<div class="row" style="justify-content: center; flex-wrap: wrap; gap: 0.5rem;">${voterSelectionHTML}</div>`,
            buttons: []
        });

        document.querySelectorAll('[data-voter-id]').forEach(button => {
            button.onclick = () => {
                const voterId = parseInt(button.dataset.voterId, 10);
                const voter = byId(voterId);
                if (voter && !this.votes[voter.id]) {
                    sounds.click();
                    this.votes[voter.id] = { targetId: target.id, isDouble: !!voter.doubleVote };
                    dom.modalTemplate.close();
                    this.renderVoteGrid();
                }
            }
        });
    }

    tallyVotes() {
        if(this.timerId) clearInterval(this.timerId);
        this.timerId = null;

        alive().filter(p => p.isBot).forEach(bot => {
            if(!this.votes[bot.id]) {
                const targetId = this.getBotVote(bot);
                if (targetId) {
                    this.votes[bot.id] = { targetId: targetId, isDouble: !!bot.doubleVote };
                } else {
                    // Fallback just in case getBotVote returns null
                    const targets = alive().filter(p => p.id !== bot.id);
                    if (targets.length > 0) this.votes[bot.id] = { targetId: targets[rand(targets.length)].id, isDouble: !!bot.doubleVote };
                }
            }
        });
        
        state.lastVotes = {};
        Object.entries(this.votes).forEach(([voterId, voteData]) => {
            state.lastVotes[voterId] = voteData.targetId;
        });

        const voteCounts = {};
        alive().forEach(p => voteCounts[p.id] = 0);
        Object.entries(this.votes).forEach(([voterId, voteData]) => {
            if (voteCounts[voteData.targetId] !== undefined) {
                 const voter = byId(parseInt(voterId));
                 voteCounts[voteData.targetId] += (voter && voter.doubleVote) ? 2 : 1;
            }
        });

        let maxVotes = -1;
        Object.values(voteCounts).forEach(c => { if(c > maxVotes) maxVotes = c; });

        if (maxVotes <= 0) {
            showModal({ title: "Aucun vote", message: "Personne n'est √©limin√© ce tour.", buttons: [{ text: "Tour suivant", onClick: checkVictory }] });
            return;
        }

        const mostVotedIds = Object.keys(voteCounts).filter(id => voteCounts[id] === maxVotes);

        if (mostVotedIds.length !== 1) {
            showModal({ title: "√âgalit√© !", message: "Plusieurs joueurs ont re√ßu le m√™me nombre de votes. Personne n'est √©limin√©.", buttons: [{ text: "Tour suivant", onClick: checkVictory }] });
        } else {
            const playerToEliminate = byId(parseInt(mostVotedIds[0], 10));
            eliminate(playerToEliminate);
        }
    }
  }

  GameController.prototype.getBotVote = function(bot) {
    const targets = alive().filter(p => p.id !== bot.id);
    if (targets.length === 0) return null;

    const civilHints = state.wordPair.hintsA || [];
    const undercoverHints = state.wordPair.hintsB || [];

    let suspects = [];
    let allies = []; // Players who seem to be on the same team

    if (bot.role === 'civil') {
        // Civil bot logic
        targets.forEach(p => {
            const p_hints = p.roundHints || [];
            if (p_hints.some(h => undercoverHints.includes(h))) {
                suspects.push(p); // This player gave a hint for the undercover word
            } else if (p_hints.some(h => civilHints.includes(h))) {
                allies.push(p); // This player gave a hint for the civil word
            }
        });

        if (suspects.length > 0) {
            // Vote for a suspect
            return suspects[rand(suspects.length)].id;
        }
        // No clear suspects, vote for someone who is not a clear ally
        const nonAllies = targets.filter(t => !allies.map(a => a.id).includes(t.id));
        if (nonAllies.length > 0) {
            return nonAllies[rand(nonAllies.length)].id;
        }

    } else if (bot.role === 'undercover') {
        // Undercover bot logic
        targets.forEach(p => {
            const p_hints = p.roundHints || [];
            if (p_hints.some(h => civilHints.includes(h))) {
                suspects.push(p); // This player gave a hint for the civil word, so they are a target
            } else if (p_hints.some(h => undercoverHints.includes(h))) {
                allies.push(p); // This player gave a hint for the undercover word
            }
        });

        if (suspects.length > 0) {
            // Vote for a "suspect" (a civil)
            return suspects[rand(suspects.length)].id;
        }
        // No clear civils to vote for, vote for someone who is not a clear ally
        const nonAllies = targets.filter(t => !allies.map(a => a.id).includes(t.id));
        if (nonAllies.length > 0) {
            return nonAllies[rand(nonAllies.length)].id;
        }
    }

    // Fallback for all cases: vote for a random player
    return targets[rand(targets.length)].id;
  };

  // ---------- INITIALIZATION ----------
  function init() {
    getDOMElements();
    initSetup();
    show('home');

    function createFloatingWord() {
      const titleContainer = document.querySelector('.title-container');
      if (!titleContainer) return;

      const words = ["Secret", "Agent", "Vote", "Civil", "Undercover", "Bluff", "Indice", "Mission", "R√©volution"];
      const word = words[Math.floor(Math.random() * words.length)];

      const span = document.createElement('span');
      span.className = 'floating-word';
      span.textContent = word;

      const containerRect = titleContainer.getBoundingClientRect();
      const x = Math.random() * (containerRect.width * 1.4) - (containerRect.width * 0.2);
      const y = Math.random() * (containerRect.height * 1.6) - (containerRect.height * 0.3);

      span.style.left = `${x}px`;
      span.style.top = `${y}px`;
      span.style.animationDelay = `${Math.random() * 2}s`;

      titleContainer.appendChild(span);

      setTimeout(() => {
          span.remove();
      }, 5000);
    }
    
    // Start floating words effect if on home screen
    if (dom.screenHome.classList.contains('active')) {
        setInterval(createFloatingWord, 1200);
    }

    dom.startGameBtn.onclick = (e) => {
        sounds.click();

        // Confetti burst effect
        const btn = e.currentTarget;
        const rect = btn.getBoundingClientRect();
        const x = rect.left + rect.width / 2;
        const y = rect.top + rect.height / 2;

        for (let i = 0; i < 40; i++) {
            const particle = document.createElement('div');
            particle.className = 'confetti-particle';
            document.body.appendChild(particle);

            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 120 + 50;
            const targetX = Math.cos(angle) * distance;
            const targetY = Math.sin(angle) * distance;

            particle.style.left = `${x}px`;
            particle.style.top = `${y}px`;
            const randomColor = `hsl(${Math.random() * 360}, 90%, 65%)`;
            particle.style.backgroundColor = randomColor;
            particle.style.setProperty('--x', `${targetX}px`);
            particle.style.setProperty('--y', `${targetY}px`);

            setTimeout(() => particle.remove(), 900);
        }

        // Delay screen transition to let the effect play
        setTimeout(() => {
            show('setup');
        }, 150);
    };

    if (dom.tipsBtn) {
        dom.tipsBtn.onclick = () => {
            sounds.click();
            const randomTip = TIPS[rand(TIPS.length)];
            showModal({
                title: "üí° Astuce du Jeu",
                message: randomTip,
                buttons: [{text: "Super !"}]
            });
        };
    }

    dom.btnReset.onclick = () => showModal({ title: "Nouvelle partie ?", message: "Toute la progression sera perdue. Voulez-vous vraiment recommencer ?", buttons: [{ text: "Annuler", class: "ghost" }, { text: "Oui, recommencer", class: "danger", onClick: () => { initSetup(); show('home'); } }] });
    dom.btnHelp.onclick = () => showModal({ title: "R√®gles du jeu", message: `<p>La majorit√© (<b>Civils</b>) re√ßoit le mot A, la minorit√© (<b>Undercover</b>) le mot B. Personne ne conna√Æt son r√¥le au d√©but. Donnez des indices, puis votez pour √©liminer un joueur.</p><p><b>Modes de jeu :</b><br><b>- Classique:</b> Jeu oral, sans timer ni √©v√©nements.<br><b>- Dynamique:</b> Avec timer et √©v√©nements al√©atoires.<br><b>- R√©volution:</b> √âv√©nements plus fr√©quents et intenses.</p><p><b>L'Innocent</b> : Ce joueur n'a aucun mot. S'il est √©limin√©, il doit deviner le mot des Civils pour gagner seul.</p><p><b>Victoire</b> : Les Civils gagnent quand il n‚Äôy a plus d‚ÄôUndercover. Les Undercover gagnent quand ils sont aussi nombreux ou plus que les autres.</p>`, buttons: [{ text: "Compris !", class: "" }] });
    dom.btnNewWord.onclick = () => showModal({ title: "Nouveau mot ?", message: "Voulez-vous vraiment relancer une manche avec un nouveau mot et les m√™mes joueurs ?", buttons: [{ text: "Annuler", class: "ghost" }, { text: "Oui, relancer", class: "warn", onClick: () => startGame(true) }] });

    dom.btnShowMyCard.onclick = () => {
        let currentPlayer, context = '';
        const gc = state._gameController;
        if (state._activeScreen === 'pass') {
            currentPlayer = state.players.filter(p => !p.isBot)[state.distributionIndex];
            context = 'de recevoir votre carte';
        } else if (gc && gc.phase === 'hint' && gc.turnOrder[gc.turnIndex]) {
            const turnPlayer = gc.turnOrder[gc.turnIndex];
            if (!turnPlayer.isBot) {
                currentPlayer = turnPlayer;
                context = 'de donner un indice';
            }
        }

        if (currentPlayer) {
            const wordToShow = currentPlayer.amnesia ? "?? (Amn√©sie)" : (currentPlayer.role === 'innocent' ? 'Vous √™tes l\'Innocent' : currentPlayer.word);
            showModal({
                title: "Confirmation",
                message: `<b>${currentPlayer.name}</b>, est-ce bien votre tour ${context} ?`,
                buttons: [
                    { text: "Non", class: "ghost" },
                    { text: "Oui, montrer ma carte", class: "", onClick: () => {
                        showModal({
                            title: `Votre carte, ${currentPlayer.name}`,
                            message: `<div style="text-align:center;"><div class="word-big">${wordToShow}</div><p style="margin-top:1rem;">R√¥le: <b>${currentPlayer.role}</b></p></div>`,
                            buttons: [{text: "Cacher"}]
                        })
                    }}
                ]
            });
        } else {
             showModal({ title: "Action impossible", message: "Vous ne pouvez voir une carte que pendant le tour d'un joueur humain.", buttons: [{text: "OK"}] });
        }
    };
    
    dom.revealCard.onclick = () => {
        dom.revealCard.classList.toggle('flipped');
        sounds.flip();
    };
  }

  document.addEventListener('DOMContentLoaded', init);

  // Particle effect initialization
  if (window.tsParticles) {
    tsParticles.load("tsparticles", {
      fpsLimit: 60,
      interactivity: {
        events: {
          onHover: {
            enable: true,
            mode: "repulse"
          },
          resize: true
        },
        modes: {
          repulse: {
            distance: 100,
            duration: 0.4
          }
        }
      },
      particles: {
        color: {
          value: "#ffffff"
        },
        links: {
          color: "#ffffff",
          distance: 150,
          enable: true,
          opacity: 0.1,
          width: 1
        },
        move: {
          direction: "none",
          enable: true,
          outModes: {
            default: "out"
          },
          random: false,
          speed: 1,
          straight: false
        },
        number: {
          density: {
            enable: true,
            area: 800
          },
          value: 80
        },
        opacity: {
          value: 0.1
        },
        shape: {
          type: "circle"
        },
        size: {
          value: { min: 1, max: 3 }
        }
      },
      detectRetina: true
    });
  }
})();
</script>
</body>
</html>
